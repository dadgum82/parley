{
  "projectName": "parley",
  "rootPath": "C:\\Users\\jrack\\IdeaProjects\\parley",
  "modules": [
    {
      "name": "parley",
      "path": "C:\\Users\\jrack\\IdeaProjects\\parley",
      "packages": [],
      "resources": {},
      "dependencies": [],
      "apiEndpoints": {}
    },
    {
      "name": "parley-api",
      "path": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-api",
      "packages": [],
      "resources": {
        "openapi\\paths\\enrollment.yaml": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-api\\src\\main\\resources\\openapi\\paths\\enrollment.yaml",
        "openapi\\paths\\chatmessage.yaml": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-api\\src\\main\\resources\\openapi\\paths\\chatmessage.yaml",
        "openapi\\schemas\\auth.yaml": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-api\\src\\main\\resources\\openapi\\schemas\\auth.yaml",
        "openapi\\paths\\auth.yaml": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-api\\src\\main\\resources\\openapi\\paths\\auth.yaml",
        "openapi\\paths\\chatroom.yaml": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-api\\src\\main\\resources\\openapi\\paths\\chatroom.yaml",
        "openapi\\schemas\\enrollment.yaml": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-api\\src\\main\\resources\\openapi\\schemas\\enrollment.yaml",
        "openapi\\security\\security.yaml": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-api\\src\\main\\resources\\openapi\\security\\security.yaml",
        "openapi\\schemas\\chatmessage.yaml": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-api\\src\\main\\resources\\openapi\\schemas\\chatmessage.yaml",
        "openapi.yaml": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-api\\src\\main\\resources\\openapi.yaml",
        "openapi\\paths\\user.yaml": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-api\\src\\main\\resources\\openapi\\paths\\user.yaml",
        "openapi\\schemas\\user.yaml": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-api\\src\\main\\resources\\openapi\\schemas\\user.yaml",
        "ValidationMessages.properties": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-api\\src\\main\\resources\\ValidationMessages.properties",
        "openapi\\schemas\\chatroom.yaml": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-api\\src\\main\\resources\\openapi\\schemas\\chatroom.yaml",
        ".swagger-codegen-ignore": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-api\\src\\main\\resources\\.swagger-codegen-ignore",
        "openapi\\resolver.yaml": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-api\\src\\main\\resources\\openapi\\resolver.yaml",
        "openapi\\schemas\\common.yaml": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-api\\src\\main\\resources\\openapi\\schemas\\common.yaml"
      },
      "dependencies": [],
      "apiEndpoints": {}
    },
    {
      "name": "parley-scripts",
      "path": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-scripts",
      "packages": [
        {
          "name": "org.sidequest.parley.scripts",
          "classes": [
            {
              "name": "AIStructureGenerator",
              "path": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-scripts\\src\\main\\java\\org\\sidequest\\parley\\scripts\\AIStructureGenerator.java",
              "type": "class",
              "imports": [
                "com.fasterxml.jackson.databind.ObjectMapper",
                "com.fasterxml.jackson.databind.SerializationFeature",
                "org.sidequest.parley.scripts.analyzers.CodeAnalyzer",
                "org.sidequest.parley.scripts.analyzers.DatabaseAnalyzer",
                "org.sidequest.parley.scripts.model.ProjectStructureModels.*",
                "java.io.File",
                "java.io.IOException",
                "java.nio.file.Files",
                "java.nio.file.Path",
                "java.nio.file.Paths",
                "java.util.*",
                "java.util.stream.Collectors"
              ],
              "annotations": [
                "@Entity",
                "@RestController",
                "@Controller"
              ],
              "content": "package org.sidequest.parley.scripts;\r\n\r\nimport com.fasterxml.jackson.databind.ObjectMapper;\r\nimport com.fasterxml.jackson.databind.SerializationFeature;\r\nimport org.sidequest.parley.scripts.analyzers.CodeAnalyzer;\r\nimport org.sidequest.parley.scripts.analyzers.DatabaseAnalyzer;\r\nimport org.sidequest.parley.scripts.model.ProjectStructureModels.*;\r\n\r\nimport java.io.File;\r\nimport java.io.IOException;\r\nimport java.nio.file.Files;\r\nimport java.nio.file.Path;\r\nimport java.nio.file.Paths;\r\nimport java.util.*;\r\nimport java.util.stream.Collectors;\r\n\r\npublic class AIStructureGenerator {\r\n    private static final ObjectMapper mapper = new ObjectMapper()\r\n            .enable(SerializationFeature.INDENT_OUTPUT);\r\n\r\n    private static final List<String> IGNORE_DIRECTORIES = Arrays.asList(\r\n            \".git\", \".idea\", \"node_modules\", \"target\", \"bin\", \"build\", \"dist\");\r\n\r\n    public static void main(String[] args) {\r\n        try {\r\n            String projectRoot = findProjectRoot();\r\n            if (projectRoot == null) {\r\n                System.out.println(\"Could not find project root directory.\");\r\n                return;\r\n            }\r\n\r\n            ProjectStructure structure = analyzeProject(new File(projectRoot));\r\n            String json = mapper.writeValueAsString(structure);\r\n\r\n            // Write to file\r\n            Path outputPath = Paths.get(projectRoot, \"ai-project-structure.json\");\r\n            Files.write(outputPath, json.getBytes());\r\n            System.out.println(\"AI-optimized project structure written to: \" + outputPath);\r\n        } catch (Exception e) {\r\n            System.err.println(\"Error generating project structure: \" + e.getMessage());\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    private static String findProjectRoot() {\r\n        Path current = Paths.get(\"\").toAbsolutePath();\r\n        while (current != null) {\r\n            if (Files.exists(current.resolve(\"pom.xml\")) ||\r\n                    Files.exists(current.resolve(\"build.gradle\")) ||\r\n                    Files.exists(current.resolve(\"package.json\"))) {\r\n                return current.toString();\r\n            }\r\n            current = current.getParent();\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private static ProjectStructure analyzeProject(File rootDir) throws IOException {\r\n        ProjectStructure structure = new ProjectStructure();\r\n        structure.projectName = rootDir.getName();\r\n        structure.rootPath = rootDir.getAbsolutePath();\r\n        structure.modules = new ArrayList<>();\r\n        structure.dependencies = new ArrayList<>();\r\n        structure.designPatterns = new HashMap<>();\r\n        structure.securityFeatures = new HashMap<>();\r\n        structure.configurations = new HashMap<>();\r\n        structure.dbSchema = new HashMap<>();\r\n\r\n        // Analyze project configuration files\r\n        analyzeProjectConfiguration(rootDir, structure);\r\n\r\n        // Find and analyze all modules\r\n        findModules(rootDir).forEach(moduleDir -> {\r\n            try {\r\n                ModuleStructure module = analyzeModule(moduleDir);\r\n                structure.modules.add(module);\r\n            } catch (IOException e) {\r\n                System.err.println(\"Error analyzing module: \" + moduleDir + \" - \" + e.getMessage());\r\n            }\r\n        });\r\n\r\n        return structure;\r\n    }\r\n\r\n    private static void analyzeProjectConfiguration(File rootDir, ProjectStructure structure) throws IOException {\r\n        // Analyze Maven POM\r\n        File pomFile = new File(rootDir, \"pom.xml\");\r\n        if (pomFile.exists()) {\r\n            analyzePomFile(pomFile, structure);\r\n        }\r\n\r\n        // Analyze Gradle build file\r\n        File gradleFile = new File(rootDir, \"build.gradle\");\r\n        if (gradleFile.exists()) {\r\n            analyzeGradleFile(gradleFile, structure);\r\n        }\r\n\r\n        // Analyze application properties/yaml files\r\n        analyzePropertyFiles(rootDir, structure);\r\n    }\r\n\r\n    private static List<File> findModules(File rootDir) {\r\n        List<File> modules = new ArrayList<>();\r\n        if (isModuleDirectory(rootDir)) {\r\n            modules.add(rootDir);\r\n        }\r\n\r\n        File[] files = rootDir.listFiles();\r\n        if (files != null) {\r\n            for (File file : files) {\r\n                if (file.isDirectory() && !IGNORE_DIRECTORIES.contains(file.getName())) {\r\n                    modules.addAll(findModules(file));\r\n                }\r\n            }\r\n        }\r\n        return modules;\r\n    }\r\n\r\n    private static boolean isModuleDirectory(File dir) {\r\n        return dir.isDirectory() && (\r\n                new File(dir, \"pom.xml\").exists() ||\r\n                        new File(dir, \"build.gradle\").exists() ||\r\n                        new File(dir, \"src\").exists()\r\n        );\r\n    }\r\n\r\n    private static ModuleStructure analyzeModule(File moduleDir) throws IOException {\r\n        ModuleStructure module = new ModuleStructure();\r\n        module.name = moduleDir.getName();\r\n        module.path = moduleDir.getAbsolutePath();\r\n        module.packages = new ArrayList<>();\r\n        module.resources = new HashMap<>();\r\n        module.dependencies = new ArrayList<>();\r\n        module.apiEndpoints = new HashMap<>();\r\n\r\n        // Analyze source files\r\n        File srcDir = new File(moduleDir, \"src/main/java\");\r\n        if (srcDir.exists()) {\r\n            analyzeSourceDirectory(srcDir, module);\r\n        }\r\n\r\n        // Analyze resources\r\n        File resourcesDir = new File(moduleDir, \"src/main/resources\");\r\n        if (resourcesDir.exists()) {\r\n            analyzeResourceDirectory(resourcesDir, module);\r\n        }\r\n\r\n        return module;\r\n    }\r\n\r\n    private static void analyzeSourceDirectory(File srcDir, ModuleStructure module) throws IOException {\r\n        Map<String, PackageStructure> packageMap = new HashMap<>();\r\n\r\n        Files.walk(srcDir.toPath())\r\n                .filter(Files::isRegularFile)\r\n                .filter(path -> path.toString().endsWith(\".java\"))\r\n                .forEach(path -> {\r\n                    try {\r\n                        File file = path.toFile();\r\n                        String packageName = calculatePackageName(srcDir, file);\r\n                        PackageStructure pkg = packageMap.computeIfAbsent(packageName,\r\n                                k -> new PackageStructure() {{\r\n                                    name = k;\r\n                                    classes = new ArrayList<>();\r\n                                }});\r\n\r\n                        ClassStructure cls = CodeAnalyzer.analyzeJavaFile(file);\r\n                        pkg.classes.add(cls);\r\n\r\n                        // Check for database entities\r\n                        if (cls.annotations.stream().anyMatch(a -> a.contains(\"@Entity\"))) {\r\n                            String content = new String(Files.readAllBytes(path));\r\n                            TableInfo tableInfo = DatabaseAnalyzer.extractTableInfo(content);\r\n                            if (tableInfo.name != null) {\r\n                                module.resources.put(\"db_table_\" + tableInfo.name, path.toString());\r\n                            }\r\n                        }\r\n\r\n                        // Check for API endpoints\r\n                        analyzeApiEndpoints(cls, module);\r\n\r\n                    } catch (IOException e) {\r\n                        System.err.println(\"Error analyzing file: \" + path + \" - \" + e.getMessage());\r\n                    }\r\n                });\r\n\r\n        module.packages.addAll(packageMap.values());\r\n    }\r\n\r\n    private static String calculatePackageName(File srcDir, File file) {\r\n        String relativePath = file.getParentFile().getAbsolutePath()\r\n                .substring(srcDir.getAbsolutePath().length() + 1);\r\n        return relativePath.replace(File.separatorChar, '.');\r\n    }\r\n\r\n    private static void analyzeApiEndpoints(ClassStructure cls, ModuleStructure module) {\r\n        if (cls.annotations.stream().anyMatch(a -> a.contains(\"@RestController\") ||\r\n                a.contains(\"@Controller\"))) {\r\n            cls.methods.forEach(method -> {\r\n                List<String> mappings = method.annotations.stream()\r\n                        .filter(a -> a.contains(\"Mapping\"))\r\n                        .collect(Collectors.toList());\r\n\r\n                if (!mappings.isEmpty()) {\r\n                    ApiEndpointInfo endpoint = new ApiEndpointInfo();\r\n                    endpoint.method = extractHttpMethod(mappings.get(0));\r\n                    endpoint.path = extractPath(mappings.get(0));\r\n                    endpoint.parameters = method.parameters;\r\n                    endpoint.responseType = method.returnType;\r\n\r\n                    module.apiEndpoints.put(endpoint.method + \" \" + endpoint.path, endpoint);\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    private static String extractHttpMethod(String mapping) {\r\n        if (mapping.contains(\"GetMapping\")) return \"GET\";\r\n        if (mapping.contains(\"PostMapping\")) return \"POST\";\r\n        if (mapping.contains(\"PutMapping\")) return \"PUT\";\r\n        if (mapping.contains(\"DeleteMapping\")) return \"DELETE\";\r\n        if (mapping.contains(\"PatchMapping\")) return \"PATCH\";\r\n        return \"UNKNOWN\";\r\n    }\r\n\r\n    private static String extractPath(String mapping) {\r\n        int startIndex = mapping.indexOf(\"(\");\r\n        int endIndex = mapping.lastIndexOf(\")\");\r\n        if (startIndex > 0 && endIndex > startIndex) {\r\n            String content = mapping.substring(startIndex + 1, endIndex);\r\n            if (content.contains(\"value = \")) {\r\n                return content.substring(content.indexOf(\"\\\"\") + 1, content.lastIndexOf(\"\\\"\"));\r\n            }\r\n            if (content.startsWith(\"\\\"\")) {\r\n                return content.substring(1, content.lastIndexOf(\"\\\"\"));\r\n            }\r\n        }\r\n        return \"/\";\r\n    }\r\n\r\n    private static void analyzeResourceDirectory(File resourcesDir, ModuleStructure module) throws IOException {\r\n        Files.walk(resourcesDir.toPath())\r\n                .filter(Files::isRegularFile)\r\n                .forEach(path -> {\r\n                    String relativePath = resourcesDir.toPath().relativize(path).toString();\r\n                    module.resources.put(relativePath, path.toString());\r\n                });\r\n    }\r\n\r\n    private static void analyzePomFile(File pomFile, ProjectStructure structure) throws IOException {\r\n        // Add basic Maven project analysis\r\n        structure.dependencies.add(\"Maven\");\r\n        // TODO: Add detailed POM analysis\r\n    }\r\n\r\n    private static void analyzeGradleFile(File gradleFile, ProjectStructure structure) throws IOException {\r\n        // Add basic Gradle project analysis\r\n        structure.dependencies.add(\"Gradle\");\r\n        // TODO: Add detailed Gradle build file analysis\r\n    }\r\n\r\n    private static void analyzePropertyFiles(File rootDir, ProjectStructure structure) throws IOException {\r\n        // Analyze application.properties/yaml files\r\n        File[] propertyFiles = rootDir.listFiles((dir, name) ->\r\n                name.startsWith(\"application.\") &&\r\n                        (name.endsWith(\".properties\") || name.endsWith(\".yml\") || name.endsWith(\".yaml\"))\r\n        );\r\n\r\n        if (propertyFiles != null) {\r\n            for (File file : propertyFiles) {\r\n                structure.configurations.put(file.getName(), file.getAbsolutePath());\r\n            }\r\n        }\r\n    }\r\n}",
              "methods": [
                {
                  "name": "main",
                  "returnType": "public static void",
                  "parameters": [
                    "String[] args"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "if",
                  "returnType": "",
                  "parameters": [
                    "projectRoot == null"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "findProjectRoot",
                  "returnType": "private static String",
                  "parameters": [],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "while",
                  "returnType": "",
                  "parameters": [
                    "current != null"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "analyzeProject",
                  "returnType": "private static ProjectStructure",
                  "parameters": [
                    "File rootDir"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": [
                    "IOException"
                  ]
                },
                {
                  "name": "ProjectStructure",
                  "returnType": "new",
                  "parameters": [],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "analyzeProjectConfiguration",
                  "returnType": "Analyze project configuration files",
                  "parameters": [
                    "rootDir",
                    "structure"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "analyzeProjectConfiguration",
                  "returnType": "private static void",
                  "parameters": [
                    "File rootDir",
                    "ProjectStructure structure"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": [
                    "IOException"
                  ]
                },
                {
                  "name": "File",
                  "returnType": "new",
                  "parameters": [
                    "rootDir",
                    "\"pom.xml\""
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "analyzePomFile",
                  "returnType": "",
                  "parameters": [
                    "pomFile",
                    "structure"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "File",
                  "returnType": "new",
                  "parameters": [
                    "rootDir",
                    "\"build.gradle\""
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "analyzeGradleFile",
                  "returnType": "",
                  "parameters": [
                    "gradleFile",
                    "structure"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "analyzePropertyFiles",
                  "returnType": "yaml files",
                  "parameters": [
                    "rootDir",
                    "structure"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "findModules",
                  "returnType": "private static List<File>",
                  "parameters": [
                    "File rootDir"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "if",
                  "returnType": "",
                  "parameters": [
                    "files != null"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "for",
                  "returnType": "",
                  "parameters": [
                    "File file : files"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "isModuleDirectory",
                  "returnType": "private static boolean",
                  "parameters": [
                    "File dir"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "analyzeModule",
                  "returnType": "private static ModuleStructure",
                  "parameters": [
                    "File moduleDir"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": [
                    "IOException"
                  ]
                },
                {
                  "name": "ModuleStructure",
                  "returnType": "new",
                  "parameters": [],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "File",
                  "returnType": "new",
                  "parameters": [
                    "moduleDir",
                    "\"src/main/java\""
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "analyzeSourceDirectory",
                  "returnType": "",
                  "parameters": [
                    "srcDir",
                    "module"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "File",
                  "returnType": "new",
                  "parameters": [
                    "moduleDir",
                    "\"src/main/resources\""
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "analyzeResourceDirectory",
                  "returnType": "",
                  "parameters": [
                    "resourcesDir",
                    "module"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "analyzeSourceDirectory",
                  "returnType": "private static void",
                  "parameters": [
                    "File srcDir",
                    "ModuleStructure module"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": [
                    "IOException"
                  ]
                },
                {
                  "name": "PackageStructure",
                  "returnType": "> new",
                  "parameters": [],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "if",
                  "returnType": "",
                  "parameters": [
                    "tableInfo.name != null"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "analyzeApiEndpoints",
                  "returnType": "Check for API endpoints",
                  "parameters": [
                    "cls",
                    "module"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "calculatePackageName",
                  "returnType": "private static String",
                  "parameters": [
                    "File srcDir",
                    "File file"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "analyzeApiEndpoints",
                  "returnType": "private static void",
                  "parameters": [
                    "ClassStructure cls",
                    "ModuleStructure module"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "ApiEndpointInfo",
                  "returnType": "new",
                  "parameters": [],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "extractHttpMethod",
                  "returnType": "private static String",
                  "parameters": [
                    "String mapping"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "extractPath",
                  "returnType": "private static String",
                  "parameters": [
                    "String mapping"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "if",
                  "returnType": "",
                  "parameters": [
                    "startIndex > 0 && endIndex > startIndex"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "analyzeResourceDirectory",
                  "returnType": "private static void",
                  "parameters": [
                    "File resourcesDir",
                    "ModuleStructure module"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": [
                    "IOException"
                  ]
                },
                {
                  "name": "analyzePomFile",
                  "returnType": "private static void",
                  "parameters": [
                    "File pomFile",
                    "ProjectStructure structure"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": [
                    "IOException"
                  ]
                },
                {
                  "name": "analyzeGradleFile",
                  "returnType": "private static void",
                  "parameters": [
                    "File gradleFile",
                    "ProjectStructure structure"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": [
                    "IOException"
                  ]
                },
                {
                  "name": "analyzePropertyFiles",
                  "returnType": "private static void",
                  "parameters": [
                    "File rootDir",
                    "ProjectStructure structure"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": [
                    "IOException"
                  ]
                },
                {
                  "name": "if",
                  "returnType": "",
                  "parameters": [
                    "propertyFiles != null"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "for",
                  "returnType": "",
                  "parameters": [
                    "File file : propertyFiles"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                }
              ],
              "businessRules": [],
              "relatedClasses": [],
              "dependencies": [
                "JPA"
              ]
            },
            {
              "name": "FixImportsSQLfile",
              "path": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-scripts\\src\\main\\java\\org\\sidequest\\parley\\scripts\\FixImportsSQLfile.java",
              "type": "class",
              "imports": [
                "java.io.File",
                "java.io.PrintWriter",
                "java.util.Scanner"
              ],
              "annotations": [],
              "content": "package org.sidequest.parley.scripts;\r\n\r\nimport java.io.File;\r\nimport java.io.PrintWriter;\r\nimport java.util.Scanner;\r\n\r\npublic class FixImportsSQLfile {\r\n    public static void main(String[] args) {\r\n        try {\r\n            String projectRoot = System.getProperty(\"user.dir\");\r\n            File inputFile = new File(projectRoot + \"\\\\parley-service-jpa\\\\src\\\\main\\\\resources\\\\import.sql\");\r\n            Scanner scanner = new Scanner(inputFile);\r\n            PrintWriter writer = new PrintWriter(projectRoot + \"\\\\parley-service-jpa\\\\src\\\\main\\\\resources\\\\reformatted_import.txt\");\r\n\r\n            StringBuilder sb = new StringBuilder();\r\n            String previousLine = null;\r\n            while (scanner.hasNextLine()) {\r\n                String line = scanner.nextLine().trim();\r\n                sb.append(line);\r\n                // Handles comments and MySQL delimiter\r\n                if (line.startsWith(\"#\") || line.startsWith(\"--\")) {\r\n\r\n                    writer.println(sb.toString());\r\n                    writer.println(\"\\n\");\r\n                    // Clear the StringBuilder for the next SQL statement\r\n                    sb.setLength(0);\r\n                }\r\n\r\n                // If the line ends with a semicolon, it's the end of a SQL statement\r\n                if (line.endsWith(\";\")) {\r\n                    writer.println(sb.toString());\r\n                    // Clear the StringBuilder for the next SQL statement\r\n                    sb.setLength(0);\r\n                } else if (!line.isEmpty() || (line.isEmpty() && (previousLine == null || !previousLine.isEmpty()))) {\r\n                    // If the line doesn't end with a semicolon, add a space before the next line\r\n                    sb.append(\" \");\r\n                }\r\n                previousLine = line;\r\n            }\r\n\r\n            scanner.close();\r\n            writer.close();\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}",
              "methods": [
                {
                  "name": "main",
                  "returnType": "public static void",
                  "parameters": [
                    "String[] args"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "File",
                  "returnType": "new",
                  "parameters": [
                    "projectRoot + \"\\\\parley-service-jpa\\\\src\\\\main\\\\resources\\\\import.sql\""
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "Scanner",
                  "returnType": "new",
                  "parameters": [
                    "inputFile"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "PrintWriter",
                  "returnType": "new",
                  "parameters": [
                    "projectRoot + \"\\\\parley-service-jpa\\\\src\\\\main\\\\resources\\\\reformatted_import.txt\""
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "StringBuilder",
                  "returnType": "new",
                  "parameters": [],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                }
              ],
              "businessRules": [],
              "relatedClasses": [],
              "dependencies": []
            },
            {
              "name": "Generate256bitKey",
              "path": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-scripts\\src\\main\\java\\org\\sidequest\\parley\\scripts\\Generate256bitKey.java",
              "type": "class",
              "imports": [
                "java.security.SecureRandom",
                "java.util.Base64"
              ],
              "annotations": [],
              "content": "package org.sidequest.parley.scripts;\r\n\r\nimport java.security.SecureRandom;\r\nimport java.util.Base64;\r\n\r\npublic class Generate256bitKey {\r\n\r\n    public static void main(String[] args) {\r\n        SecureRandom secureRandom = new SecureRandom();\r\n        byte[] key = new byte[32];\r\n        secureRandom.nextBytes(key);\r\n        String secret = Base64.getEncoder().encodeToString(key);\r\n        System.out.println(\"The new secret key is: \" + secret);\r\n    }\r\n}\r\n",
              "methods": [
                {
                  "name": "main",
                  "returnType": "public static void",
                  "parameters": [
                    "String[] args"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "SecureRandom",
                  "returnType": "new",
                  "parameters": [],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                }
              ],
              "businessRules": [],
              "relatedClasses": [],
              "dependencies": []
            }
          ]
        },
        {
          "name": "org.sidequest.parley.scripts.model",
          "classes": [
            {
              "name": "ProjectStructureModels",
              "path": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-scripts\\src\\main\\java\\org\\sidequest\\parley\\scripts\\model\\ProjectStructureModels.java",
              "type": "class",
              "imports": [
                "java.util.List",
                "java.util.Map"
              ],
              "annotations": [],
              "content": "package org.sidequest.parley.scripts.model;\r\n\r\nimport java.util.List;\r\nimport java.util.Map;\r\n\r\npublic class ProjectStructureModels {\r\n    public static class ProjectStructure {\r\n        public String projectName;\r\n        public String rootPath;\r\n        public List<ModuleStructure> modules;\r\n        public List<String> dependencies;\r\n        public Map<String, List<String>> designPatterns;\r\n        public Map<String, List<String>> securityFeatures;\r\n        public Map<String, String> configurations;\r\n        public Map<String, TableInfo> dbSchema;\r\n    }\r\n\r\n    public static class ModuleStructure {\r\n        public String name;\r\n        public String path;\r\n        public List<PackageStructure> packages;\r\n        public Map<String, String> resources;\r\n        public List<String> dependencies;\r\n        public Map<String, ApiEndpointInfo> apiEndpoints;\r\n    }\r\n\r\n    public static class PackageStructure {\r\n        public String name;\r\n        public List<ClassStructure> classes;\r\n    }\r\n\r\n    public static class ClassStructure {\r\n        public String name;\r\n        public String path;\r\n        public String type;\r\n        public List<String> imports;\r\n        public List<String> annotations;\r\n        public String content;\r\n        public List<MethodInfo> methods;\r\n        public List<String> businessRules;\r\n        public List<String> relatedClasses;\r\n        public List<String> dependencies;\r\n    }\r\n\r\n    public static class MethodInfo {\r\n        public String name;\r\n        public String returnType;\r\n        public List<String> parameters;\r\n        public List<String> annotations;\r\n        public String visibility;\r\n        public boolean isAsync;\r\n        public List<String> exceptions;\r\n    }\r\n\r\n    public static class ApiEndpointInfo {\r\n        public String path;\r\n        public String method;\r\n        public String description;\r\n        public List<String> parameters;\r\n        public String requestBody;\r\n        public String responseType;\r\n    }\r\n\r\n    public static class TableInfo {\r\n        public String name;\r\n        public List<ColumnInfo> columns;\r\n        public List<String> relationships;\r\n    }\r\n\r\n    public static class ColumnInfo {\r\n        public String name;\r\n        public String type;\r\n        public boolean isPrimaryKey;\r\n        public boolean isForeignKey;\r\n        public String referencedTable;\r\n        public String referencedColumn;\r\n        public boolean isNullable;\r\n        public String defaultValue;\r\n    }\r\n}",
              "methods": [],
              "businessRules": [],
              "relatedClasses": [],
              "dependencies": []
            }
          ]
        },
        {
          "name": "org.sidequest.parley.scripts.analyzers",
          "classes": [
            {
              "name": "CodeAnalyzer",
              "path": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-scripts\\src\\main\\java\\org\\sidequest\\parley\\scripts\\analyzers\\CodeAnalyzer.java",
              "type": "class",
              "imports": [
                "org.apache.commons.io.FileUtils",
                "org.sidequest.parley.scripts.model.ProjectStructureModels.ClassStructure",
                "org.sidequest.parley.scripts.model.ProjectStructureModels.MethodInfo",
                "java.io.File",
                "java.io.IOException",
                "java.nio.charset.StandardCharsets",
                "java.util.*",
                "java.util.regex.Matcher",
                "java.util.regex.Pattern",
                "java.util.stream.Collectors"
              ],
              "annotations": [
                "@interface",
                "@Autowired",
                "@Component",
                "@Service",
                "@Repository",
                "@Entity",
                "@Table",
                "@Column",
                "@Secured",
                "@PreAuthorize",
                "@RolesAllowed",
                "@Test",
                "@Mock",
                "@MockBean"
              ],
              "content": "package org.sidequest.parley.scripts.analyzers;\r\n\r\nimport org.apache.commons.io.FileUtils;\r\nimport org.sidequest.parley.scripts.model.ProjectStructureModels.ClassStructure;\r\nimport org.sidequest.parley.scripts.model.ProjectStructureModels.MethodInfo;\r\n\r\nimport java.io.File;\r\nimport java.io.IOException;\r\nimport java.nio.charset.StandardCharsets;\r\nimport java.util.*;\r\nimport java.util.regex.Matcher;\r\nimport java.util.regex.Pattern;\r\nimport java.util.stream.Collectors;\r\n\r\npublic class CodeAnalyzer {\r\n    private static final Pattern IMPORT_PATTERN =\r\n            Pattern.compile(\"import\\\\s+([\\\\w\\\\.\\\\*]+);\");\r\n    private static final Pattern ANNOTATION_PATTERN =\r\n            Pattern.compile(\"@([\\\\w\\\\.]+)(?:\\\\([^)]*\\\\))?\");\r\n    private static final Pattern METHOD_PATTERN = Pattern.compile(\r\n            \"(?<visibility>public|private|protected)?\\\\s*\" +\r\n                    \"(?<static>static\\\\s+)?\" +\r\n                    \"(?<final>final\\\\s+)?\" +\r\n                    \"(?<async>async\\\\s+)?\" +\r\n                    \"(?<generic><[^>]+>\\\\s*)?\" +\r\n                    \"(?<returnType>[\\\\w\\\\<\\\\>\\\\[\\\\]\\\\s\\\\.]+)\\\\s+\" +\r\n                    \"(?<name>\\\\w+)\\\\s*\" +\r\n                    \"\\\\((?<params>[^)]*)\\\\)\\\\s*\" +\r\n                    \"(?<throws>throws\\\\s+[\\\\w\\\\s,\\\\.]+)?\\\\s*\" +\r\n                    \"(?:\\\\{|;)\", // Handle both method bodies and interface methods\r\n            Pattern.MULTILINE\r\n    );\r\n\r\n    private static final Pattern METHOD_ANNOTATION_PATTERN = Pattern.compile(\r\n            \"@([\\\\w\\\\.]+)(?:\\\\([^)]*\\\\))?\\\\s*$\",\r\n            Pattern.MULTILINE\r\n    );\r\n\r\n    public static ClassStructure analyzeJavaFile(File file) throws IOException {\r\n        if (file == null || !file.exists()) {\r\n            throw new IllegalArgumentException(\"Invalid file provided for analysis\");\r\n        }\r\n\r\n        ClassStructure cls = new ClassStructure();\r\n        cls.name = file.getName().replace(\".java\", \"\");\r\n        cls.path = file.getAbsolutePath();\r\n\r\n        try {\r\n            String content = FileUtils.readFileToString(file, StandardCharsets.UTF_8);\r\n            cls.content = content;\r\n\r\n            cls.imports = extractImports(content);\r\n            cls.annotations = extractAnnotations(content);\r\n            cls.type = determineClassType(content);\r\n            cls.methods = extractMethods(content);\r\n            cls.businessRules = extractBusinessRules(content);\r\n            cls.relatedClasses = findRelatedClasses(content);\r\n            cls.dependencies = findDependencies(content);\r\n\r\n            return cls;\r\n        } catch (IOException e) {\r\n            throw new IOException(\"Failed to analyze Java file: \" + file.getName(), e);\r\n        }\r\n    }\r\n\r\n    public static List<String> extractImports(String content) {\r\n        if (content == null || content.isEmpty()) {\r\n            return new ArrayList<>();\r\n        }\r\n\r\n        List<String> imports = new ArrayList<>();\r\n        Matcher matcher = IMPORT_PATTERN.matcher(content);\r\n        while (matcher.find()) {\r\n            imports.add(matcher.group(1));\r\n        }\r\n        return imports;\r\n    }\r\n\r\n    public static List<String> extractAnnotations(String content) {\r\n        if (content == null || content.isEmpty()) {\r\n            return new ArrayList<>();\r\n        }\r\n\r\n        List<String> annotations = new ArrayList<>();\r\n        Matcher matcher = ANNOTATION_PATTERN.matcher(content);\r\n        while (matcher.find()) {\r\n            annotations.add(matcher.group());\r\n        }\r\n        return annotations;\r\n    }\r\n\r\n    public static List<MethodInfo> extractMethods(String content) {\r\n        if (content == null || content.isEmpty()) {\r\n            return new ArrayList<>();\r\n        }\r\n\r\n        List<MethodInfo> methods = new ArrayList<>();\r\n        Matcher matcher = METHOD_PATTERN.matcher(content);\r\n\r\n        while (matcher.find()) {\r\n            try {\r\n                MethodInfo method = new MethodInfo();\r\n                method.name = matcher.group(\"name\");\r\n\r\n                String returnType = matcher.group(\"returnType\");\r\n                String generic = matcher.group(\"generic\");\r\n                method.returnType = (generic != null) ? generic.trim() + \" \" + returnType.trim() : returnType.trim();\r\n\r\n                method.visibility = matcher.group(\"visibility\") != null ?\r\n                        matcher.group(\"visibility\") : \"package-private\";\r\n                method.isAsync = matcher.group(\"async\") != null;\r\n                method.parameters = parseParameters(matcher.group(\"params\"));\r\n                method.annotations = extractMethodAnnotations(\r\n                        content.substring(Math.max(0, matcher.start() - 200), matcher.start())\r\n                );\r\n                method.exceptions = parseExceptions(matcher.group(\"throws\"));\r\n                methods.add(method);\r\n            } catch (Exception e) {\r\n                System.err.println(\"Error parsing method at position \" + matcher.start() + \": \" + e.getMessage());\r\n            }\r\n        }\r\n        return methods;\r\n    }\r\n\r\n    private static List<String> extractMethodAnnotations(String precedingContent) {\r\n        if (precedingContent == null || precedingContent.isEmpty()) {\r\n            return new ArrayList<>();\r\n        }\r\n\r\n        List<String> annotations = new ArrayList<>();\r\n        Matcher matcher = METHOD_ANNOTATION_PATTERN.matcher(precedingContent);\r\n        while (matcher.find()) {\r\n            annotations.add(matcher.group());\r\n        }\r\n        return annotations;\r\n    }\r\n\r\n    private static List<String> parseParameters(String params) {\r\n        if (params == null || params.trim().isEmpty()) {\r\n            return new ArrayList<>();\r\n        }\r\n        return Arrays.stream(params.split(\",\"))\r\n                .map(String::trim)\r\n                .filter(s -> !s.isEmpty())\r\n                .collect(Collectors.toList());\r\n    }\r\n\r\n    private static List<String> parseExceptions(String throwsClause) {\r\n        if (throwsClause == null || throwsClause.trim().isEmpty()) {\r\n            return new ArrayList<>();\r\n        }\r\n        return Arrays.stream(throwsClause.replace(\"throws\", \"\").split(\",\"))\r\n                .map(String::trim)\r\n                .filter(s -> !s.isEmpty())\r\n                .collect(Collectors.toList());\r\n    }\r\n\r\n    public static List<String> extractBusinessRules(String content) {\r\n        if (content == null || content.isEmpty()) {\r\n            return new ArrayList<>();\r\n        }\r\n\r\n        List<String> rules = new ArrayList<>();\r\n        Pattern pattern = Pattern.compile(\r\n                \"/\\\\*\\\\*\\\\s*(.*?)\\\\s*\\\\*/|//\\\\s*(.+)\",\r\n                Pattern.DOTALL | Pattern.MULTILINE\r\n        );\r\n        Matcher matcher = pattern.matcher(content);\r\n        while (matcher.find()) {\r\n            try {\r\n                String comment = matcher.group(1) != null ? matcher.group(1) : matcher.group(2);\r\n                if (comment != null && (\r\n                        comment.toLowerCase().contains(\"rule\") ||\r\n                                comment.toLowerCase().contains(\"validation\") ||\r\n                                comment.toLowerCase().contains(\"requirement\"))) {\r\n                    rules.add(comment.trim());\r\n                }\r\n            } catch (Exception e) {\r\n                System.err.println(\"Error parsing business rule comment: \" + e.getMessage());\r\n            }\r\n        }\r\n        return rules;\r\n    }\r\n\r\n    public static String determineClassType(String content) {\r\n        if (content == null || content.isEmpty()) {\r\n            return \"unknown\";\r\n        }\r\n\r\n        // Use more precise pattern matching to avoid false positives\r\n        Pattern classPattern = Pattern.compile(\"\\\\s(class|interface|enum|@interface|record)\\\\s\");\r\n        Matcher matcher = classPattern.matcher(content);\r\n\r\n        if (matcher.find()) {\r\n            return matcher.group(1);\r\n        }\r\n\r\n        return \"class\"; // default to class if no specific type is found\r\n    }\r\n\r\n    private static List<String> findRelatedClasses(String content) {\r\n        if (content == null || content.isEmpty()) {\r\n            return new ArrayList<>();\r\n        }\r\n\r\n        Set<String> related = new HashSet<>();\r\n        Pattern pattern = Pattern.compile(\r\n                \"(?:extends|implements|<)\\\\s+([\\\\w\\\\s,\\\\.]+)(?:>|\\\\{|\\\\s)\"\r\n        );\r\n        Matcher matcher = pattern.matcher(content);\r\n        while (matcher.find()) {\r\n            Arrays.stream(matcher.group(1).split(\",\"))\r\n                    .map(String::trim)\r\n                    .filter(s -> !s.isEmpty())\r\n                    .forEach(related::add);\r\n        }\r\n        return new ArrayList<>(related);\r\n    }\r\n\r\n    private static List<String> findDependencies(String content) {\r\n        if (content == null || content.isEmpty()) {\r\n            return new ArrayList<>();\r\n        }\r\n\r\n        Set<String> dependencies = new HashSet<>();\r\n\r\n        // Spring Framework dependencies\r\n        if (content.contains(\"@Autowired\") ||\r\n                content.contains(\"@Component\") ||\r\n                content.contains(\"@Service\") ||\r\n                content.contains(\"@Repository\")) {\r\n            dependencies.add(\"Spring Framework\");\r\n        }\r\n\r\n        // JPA dependencies\r\n        if (content.contains(\"@Entity\") ||\r\n                content.contains(\"@Table\") ||\r\n                content.contains(\"@Column\")) {\r\n            dependencies.add(\"JPA\");\r\n        }\r\n\r\n        // Security dependencies\r\n        if (content.contains(\"@Secured\") ||\r\n                content.contains(\"@PreAuthorize\") ||\r\n                content.contains(\"@RolesAllowed\")) {\r\n            dependencies.add(\"Spring Security\");\r\n        }\r\n\r\n        // Testing dependencies\r\n        if (content.contains(\"@Test\") ||\r\n                content.contains(\"@Mock\") ||\r\n                content.contains(\"@MockBean\")) {\r\n            dependencies.add(\"Testing Framework\");\r\n        }\r\n\r\n        return new ArrayList<>(dependencies);\r\n    }\r\n}",
              "methods": [
                {
                  "name": "analyzeJavaFile",
                  "returnType": "public static ClassStructure",
                  "parameters": [
                    "File file"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": [
                    "IOException"
                  ]
                },
                {
                  "name": "IllegalArgumentException",
                  "returnType": "throw new",
                  "parameters": [
                    "\"Invalid file provided for analysis\""
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "ClassStructure",
                  "returnType": "new",
                  "parameters": [],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "extractImports",
                  "returnType": "public static List<String>",
                  "parameters": [
                    "String content"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "extractAnnotations",
                  "returnType": "public static List<String>",
                  "parameters": [
                    "String content"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "extractMethods",
                  "returnType": "public static List<MethodInfo>",
                  "parameters": [
                    "String content"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "MethodInfo",
                  "returnType": "new",
                  "parameters": [],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "extractMethodAnnotations",
                  "returnType": "private static List<String>",
                  "parameters": [
                    "String precedingContent"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "parseParameters",
                  "returnType": "private static List<String>",
                  "parameters": [
                    "String params"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "parseExceptions",
                  "returnType": "private static List<String>",
                  "parameters": [
                    "String throwsClause"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "extractBusinessRules",
                  "returnType": "public static List<String>",
                  "parameters": [
                    "String content"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "determineClassType",
                  "returnType": "public static String",
                  "parameters": [
                    "String content"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "findRelatedClasses",
                  "returnType": "private static List<String>",
                  "parameters": [
                    "String content"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "findDependencies",
                  "returnType": "private static List<String>",
                  "parameters": [
                    "String content"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                }
              ],
              "businessRules": [
                "Handle both method bodies and interface methods\r\n            Pattern.MULTILINE\r\n    );\r\n\r\n    private static final Pattern METHOD_ANNOTATION_PATTERN = Pattern.compile(\r\n            \"@([\\\\w\\\\.]+)(?:\\\\([^)]*\\\\))?\\\\s*$\",\r\n            Pattern.MULTILINE\r\n    );\r\n\r\n    public static ClassStructure analyzeJavaFile(File file) throws IOException {\r\n        if (file == null || !file.exists()) {\r\n            throw new IllegalArgumentException(\"Invalid file provided for analysis\");\r\n        }\r\n\r\n        ClassStructure cls = new ClassStructure();\r\n        cls.name = file.getName().replace(\".java\", \"\");\r\n        cls.path = file.getAbsolutePath();\r\n\r\n        try {\r\n            String content = FileUtils.readFileToString(file, StandardCharsets.UTF_8);\r\n            cls.content = content;\r\n\r\n            cls.imports = extractImports(content);\r\n            cls.annotations = extractAnnotations(content);\r\n            cls.type = determineClassType(content);\r\n            cls.methods = extractMethods(content);\r\n            cls.businessRules = extractBusinessRules(content);\r\n            cls.relatedClasses = findRelatedClasses(content);\r\n            cls.dependencies = findDependencies(content);\r\n\r\n            return cls;\r\n        } catch (IOException e) {\r\n            throw new IOException(\"Failed to analyze Java file: \" + file.getName(), e);\r\n        }\r\n    }\r\n\r\n    public static List<String> extractImports(String content) {\r\n        if (content == null || content.isEmpty()) {\r\n            return new ArrayList<>();\r\n        }\r\n\r\n        List<String> imports = new ArrayList<>();\r\n        Matcher matcher = IMPORT_PATTERN.matcher(content);\r\n        while (matcher.find()) {\r\n            imports.add(matcher.group(1));\r\n        }\r\n        return imports;\r\n    }\r\n\r\n    public static List<String> extractAnnotations(String content) {\r\n        if (content == null || content.isEmpty()) {\r\n            return new ArrayList<>();\r\n        }\r\n\r\n        List<String> annotations = new ArrayList<>();\r\n        Matcher matcher = ANNOTATION_PATTERN.matcher(content);\r\n        while (matcher.find()) {\r\n            annotations.add(matcher.group());\r\n        }\r\n        return annotations;\r\n    }\r\n\r\n    public static List<MethodInfo> extractMethods(String content) {\r\n        if (content == null || content.isEmpty()) {\r\n            return new ArrayList<>();\r\n        }\r\n\r\n        List<MethodInfo> methods = new ArrayList<>();\r\n        Matcher matcher = METHOD_PATTERN.matcher(content);\r\n\r\n        while (matcher.find()) {\r\n            try {\r\n                MethodInfo method = new MethodInfo();\r\n                method.name = matcher.group(\"name\");\r\n\r\n                String returnType = matcher.group(\"returnType\");\r\n                String generic = matcher.group(\"generic\");\r\n                method.returnType = (generic != null) ? generic.trim() + \" \" + returnType.trim() : returnType.trim();\r\n\r\n                method.visibility = matcher.group(\"visibility\") != null ?\r\n                        matcher.group(\"visibility\") : \"package-private\";\r\n                method.isAsync = matcher.group(\"async\") != null;\r\n                method.parameters = parseParameters(matcher.group(\"params\"));\r\n                method.annotations = extractMethodAnnotations(\r\n                        content.substring(Math.max(0, matcher.start() - 200), matcher.start())\r\n                );\r\n                method.exceptions = parseExceptions(matcher.group(\"throws\"));\r\n                methods.add(method);\r\n            } catch (Exception e) {\r\n                System.err.println(\"Error parsing method at position \" + matcher.start() + \": \" + e.getMessage());\r\n            }\r\n        }\r\n        return methods;\r\n    }\r\n\r\n    private static List<String> extractMethodAnnotations(String precedingContent) {\r\n        if (precedingContent == null || precedingContent.isEmpty()) {\r\n            return new ArrayList<>();\r\n        }\r\n\r\n        List<String> annotations = new ArrayList<>();\r\n        Matcher matcher = METHOD_ANNOTATION_PATTERN.matcher(precedingContent);\r\n        while (matcher.find()) {\r\n            annotations.add(matcher.group());\r\n        }\r\n        return annotations;\r\n    }\r\n\r\n    private static List<String> parseParameters(String params) {\r\n        if (params == null || params.trim().isEmpty()) {\r\n            return new ArrayList<>();\r\n        }\r\n        return Arrays.stream(params.split(\",\"))\r\n                .map(String::trim)\r\n                .filter(s -> !s.isEmpty())\r\n                .collect(Collectors.toList());\r\n    }\r\n\r\n    private static List<String> parseExceptions(String throwsClause) {\r\n        if (throwsClause == null || throwsClause.trim().isEmpty()) {\r\n            return new ArrayList<>();\r\n        }\r\n        return Arrays.stream(throwsClause.replace(\"throws\", \"\").split(\",\"))\r\n                .map(String::trim)\r\n                .filter(s -> !s.isEmpty())\r\n                .collect(Collectors.toList());\r\n    }\r\n\r\n    public static List<String> extractBusinessRules(String content) {\r\n        if (content == null || content.isEmpty()) {\r\n            return new ArrayList<>();\r\n        }\r\n\r\n        List<String> rules = new ArrayList<>();\r\n        Pattern pattern = Pattern.compile(\r\n                \"/\\\\*\\\\*\\\\s*(.*?)\\\\s*\\\\*/|//\\\\s*(.+)\",\r\n                Pattern.DOTALL | Pattern.MULTILINE\r\n        );\r\n        Matcher matcher = pattern.matcher(content);\r\n        while (matcher.find()) {\r\n            try {\r\n                String comment = matcher.group(1) != null ? matcher.group(1) : matcher.group(2);\r\n                if (comment != null && (\r\n                        comment.toLowerCase().contains(\"rule\") ||\r\n                                comment.toLowerCase().contains(\"validation\") ||\r\n                                comment.toLowerCase().contains(\"requirement\"))) {\r\n                    rules.add(comment.trim());\r\n                }\r\n            } catch (Exception e) {\r\n                System.err.println(\"Error parsing business rule comment: \" + e.getMessage());\r\n            }\r\n        }\r\n        return rules;\r\n    }\r\n\r\n    public static String determineClassType(String content) {\r\n        if (content == null || content.isEmpty()) {\r\n            return \"unknown\";\r\n        }\r\n\r\n        // Use more precise pattern matching to avoid false positives\r\n        Pattern classPattern = Pattern.compile(\"\\\\s(class|interface|enum|@interface|record)\\\\s\");\r\n        Matcher matcher = classPattern.matcher(content);\r\n\r\n        if (matcher.find()) {\r\n            return matcher.group(1);\r\n        }\r\n\r\n        return \"class\"; // default to class if no specific type is found\r\n    }\r\n\r\n    private static List<String> findRelatedClasses(String content) {\r\n        if (content == null || content.isEmpty()) {\r\n            return new ArrayList<>();\r\n        }\r\n\r\n        Set<String> related = new HashSet<>();\r\n        Pattern pattern = Pattern.compile(\r\n                \"(?:extends|implements|<)\\\\s+([\\\\w\\\\s,\\\\.]+)(?:>|\\\\{|\\\\s)\"\r\n        );\r\n        Matcher matcher = pattern.matcher(content);\r\n        while (matcher.find()) {\r\n            Arrays.stream(matcher.group(1).split(\",\"))\r\n                    .map(String::trim)\r\n                    .filter(s -> !s.isEmpty())\r\n                    .forEach(related::add);\r\n        }\r\n        return new ArrayList<>(related);\r\n    }\r\n\r\n    private static List<String> findDependencies(String content) {\r\n        if (content == null || content.isEmpty()) {\r\n            return new ArrayList<>();\r\n        }\r\n\r\n        Set<String> dependencies = new HashSet<>();\r\n\r\n        // Spring Framework dependencies\r\n        if (content.contains(\"@Autowired\") ||\r\n                content.contains(\"@Component\") ||\r\n                content.contains(\"@Service\") ||\r\n                content.contains(\"@Repository\")) {\r\n            dependencies.add(\"Spring Framework\");\r\n        }\r\n\r\n        // JPA dependencies\r\n        if (content.contains(\"@Entity\") ||\r\n                content.contains(\"@Table\") ||\r\n                content.contains(\"@Column\")) {\r\n            dependencies.add(\"JPA\");\r\n        }\r\n\r\n        // Security dependencies\r\n        if (content.contains(\"@Secured\") ||\r\n                content.contains(\"@PreAuthorize\") ||\r\n                content.contains(\"@RolesAllowed\")) {\r\n            dependencies.add(\"Spring Security\");\r\n        }\r\n\r\n        // Testing dependencies\r\n        if (content.contains(\"@Test\") ||\r\n                content.contains(\"@Mock\") ||\r\n                content.contains(\"@MockBean\")) {\r\n            dependencies.add(\"Testing Framework\");\r\n        }\r\n\r\n        return new ArrayList<>(dependencies);\r\n    }\r\n}"
              ],
              "relatedClasses": [],
              "dependencies": [
                "Testing Framework",
                "Spring Framework",
                "JPA",
                "Spring Security"
              ]
            },
            {
              "name": "DatabaseAnalyzer",
              "path": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-scripts\\src\\main\\java\\org\\sidequest\\parley\\scripts\\analyzers\\DatabaseAnalyzer.java",
              "type": "class",
              "imports": [
                "org.sidequest.parley.scripts.model.ProjectStructureModels.ColumnInfo",
                "org.sidequest.parley.scripts.model.ProjectStructureModels.TableInfo",
                "java.util.ArrayList",
                "java.util.regex.Matcher",
                "java.util.regex.Pattern"
              ],
              "annotations": [
                "@Table",
                "@Column",
                "@Id",
                "@ManyToOne",
                "@JoinColumn"
              ],
              "content": "package org.sidequest.parley.scripts.analyzers;\r\n\r\nimport org.sidequest.parley.scripts.model.ProjectStructureModels.ColumnInfo;\r\nimport org.sidequest.parley.scripts.model.ProjectStructureModels.TableInfo;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.regex.Matcher;\r\nimport java.util.regex.Pattern;\r\n\r\npublic class DatabaseAnalyzer {\r\n    private static final Pattern TABLE_PATTERN =\r\n            Pattern.compile(\"@Table\\\\(name\\\\s*=\\\\s*\\\"([^\\\"]+)\\\"\\\\)\");\r\n    private static final Pattern COLUMN_PATTERN =\r\n            Pattern.compile(\"@Column\\\\(([^)]+)\\\\)\\\\s+private\\\\s+([^\\\\s]+)\\\\s+([^\\\\s;]+)\");\r\n    private static final Pattern ID_PATTERN =\r\n            Pattern.compile(\"@Id\");\r\n    private static final Pattern MANY_TO_ONE_PATTERN =\r\n            Pattern.compile(\"@ManyToOne[^)]*\\\\)[^\\\\n]*\\\\n[^@]*@JoinColumn\\\\(([^)]+)\\\\)\");\r\n\r\n    public static TableInfo extractTableInfo(String content) {\r\n        TableInfo table = new TableInfo();\r\n        table.columns = new ArrayList<>();\r\n        table.relationships = new ArrayList<>();\r\n\r\n        // Extract table name\r\n        Matcher tableMatcher = TABLE_PATTERN.matcher(content);\r\n        if (tableMatcher.find()) {\r\n            table.name = tableMatcher.group(1);\r\n        }\r\n\r\n        // Extract columns\r\n        String[] lines = content.split(\"\\\\n\");\r\n        for (int i = 0; i < lines.length; i++) {\r\n            String line = lines[i];\r\n\r\n            // Check for ID\r\n            boolean isId = ID_PATTERN.matcher(line).find();\r\n\r\n            // Extract column info\r\n            Matcher columnMatcher = COLUMN_PATTERN.matcher(line);\r\n            if (columnMatcher.find()) {\r\n                ColumnInfo column = new ColumnInfo();\r\n                column.isPrimaryKey = isId;\r\n                parseColumnAttributes(columnMatcher.group(1), column);\r\n                column.type = columnMatcher.group(2);\r\n                column.name = columnMatcher.group(3);\r\n                table.columns.add(column);\r\n            }\r\n\r\n            // Extract relationships\r\n            Matcher relationMatcher = MANY_TO_ONE_PATTERN.matcher(line);\r\n            if (relationMatcher.find()) {\r\n                String relationshipInfo = relationshipInfo(relationMatcher.group(1));\r\n                table.relationships.add(relationshipInfo);\r\n            }\r\n        }\r\n\r\n        return table;\r\n    }\r\n\r\n    private static void parseColumnAttributes(String attributes, ColumnInfo column) {\r\n        // Parse nullability\r\n        column.isNullable = !attributes.contains(\"nullable = false\");\r\n\r\n        // Parse length if present\r\n        Pattern lengthPattern = Pattern.compile(\"length\\\\s*=\\\\s*(\\\\d+)\");\r\n        Matcher lengthMatcher = lengthPattern.matcher(attributes);\r\n        if (lengthMatcher.find()) {\r\n            // You might want to store this somewhere\r\n        }\r\n\r\n        // Parse default value if present\r\n        Pattern defaultPattern = Pattern.compile(\"columnDefinition\\\\s*=\\\\s*\\\"([^\\\"]+)\\\"\");\r\n        Matcher defaultMatcher = defaultPattern.matcher(attributes);\r\n        if (defaultMatcher.find()) {\r\n            column.defaultValue = defaultMatcher.group(1);\r\n        }\r\n    }\r\n\r\n    private static String relationshipInfo(String attributes) {\r\n        Pattern namePattern = Pattern.compile(\"name\\\\s*=\\\\s*\\\"([^\\\"]+)\\\"\");\r\n        Matcher nameMatcher = namePattern.matcher(attributes);\r\n        if (nameMatcher.find()) {\r\n            return \"References table via \" + nameMatcher.group(1);\r\n        }\r\n        return \"Unknown relationship\";\r\n    }\r\n}",
              "methods": [
                {
                  "name": "extractTableInfo",
                  "returnType": "public static TableInfo",
                  "parameters": [
                    "String content"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "TableInfo",
                  "returnType": "new",
                  "parameters": [],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "for",
                  "returnType": "",
                  "parameters": [
                    "int i = 0; i < lines.length; i++"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "ColumnInfo",
                  "returnType": "new",
                  "parameters": [],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "parseColumnAttributes",
                  "returnType": "private static void",
                  "parameters": [
                    "String attributes",
                    "ColumnInfo column"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "relationshipInfo",
                  "returnType": "private static String",
                  "parameters": [
                    "String attributes"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                }
              ],
              "businessRules": [],
              "relatedClasses": [],
              "dependencies": [
                "JPA"
              ]
            }
          ]
        }
      ],
      "resources": {},
      "dependencies": [],
      "apiEndpoints": {}
    },
    {
      "name": "parley-service-jpa",
      "path": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-service-jpa",
      "packages": [
        {
          "name": "org.sidequest.parley.exception",
          "classes": [
            {
              "name": "ValidationException",
              "path": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-service-jpa\\src\\main\\java\\org\\sidequest\\parley\\exception\\ValidationException.java",
              "type": "class",
              "imports": [
                "java.util.Map"
              ],
              "annotations": [],
              "content": "package org.sidequest.parley.exception;\r\n\r\nimport java.util.Map;\r\n\r\npublic class ValidationException extends RuntimeException {\r\n    private final Map<String, String> errors;\r\n\r\n    public ValidationException(String message) {\r\n        super(message);\r\n        this.errors = null;\r\n    }\r\n\r\n    public ValidationException(String message, Map<String, String> errors) {\r\n        super(message);\r\n        this.errors = errors;\r\n    }\r\n\r\n    public Map<String, String> getErrors() {\r\n        return errors;\r\n    }\r\n}",
              "methods": [
                {
                  "name": "ValidationException",
                  "returnType": "public",
                  "parameters": [
                    "String message"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "super",
                  "returnType": "",
                  "parameters": [
                    "message"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "ValidationException",
                  "returnType": "public",
                  "parameters": [
                    "String message",
                    "Map<String",
                    "String> errors"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "super",
                  "returnType": "",
                  "parameters": [
                    "message"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "getErrors",
                  "returnType": "String>",
                  "parameters": [],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                }
              ],
              "businessRules": [],
              "relatedClasses": [
                "RuntimeException"
              ],
              "dependencies": []
            }
          ]
        },
        {
          "name": "org.sidequest.parley.repository",
          "classes": [
            {
              "name": "ChatMessageRepository",
              "path": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-service-jpa\\src\\main\\java\\org\\sidequest\\parley\\repository\\ChatMessageRepository.java",
              "type": "interface",
              "imports": [
                "org.sidequest.parley.entity.ChatMessageEntity",
                "org.springframework.data.jpa.repository.JpaRepository",
                "org.springframework.stereotype.Repository",
                "java.util.List"
              ],
              "annotations": [
                "@Repository"
              ],
              "content": "package org.sidequest.parley.repository;\r\n\r\nimport org.sidequest.parley.entity.ChatMessageEntity;\r\nimport org.springframework.data.jpa.repository.JpaRepository;\r\nimport org.springframework.stereotype.Repository;\r\n\r\nimport java.util.List;\r\n\r\n@Repository // This is an addition to try the mapper\r\npublic interface ChatMessageRepository extends JpaRepository<ChatMessageEntity, Long> {\r\n    List<ChatMessageEntity> findByChatRoomId(Long chatRoomId);\r\n}",
              "methods": [
                {
                  "name": "findByChatRoomId",
                  "returnType": "List<ChatMessageEntity>",
                  "parameters": [
                    "Long chatRoomId"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                }
              ],
              "businessRules": [],
              "relatedClasses": [],
              "dependencies": [
                "Spring Framework"
              ]
            },
            {
              "name": "ChatRoomRepository",
              "path": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-service-jpa\\src\\main\\java\\org\\sidequest\\parley\\repository\\ChatRoomRepository.java",
              "type": "interface",
              "imports": [
                "org.sidequest.parley.entity.ChatRoomEntity",
                "org.springframework.data.jpa.repository.JpaRepository",
                "org.springframework.stereotype.Repository"
              ],
              "annotations": [
                "@Repository"
              ],
              "content": "package org.sidequest.parley.repository;\r\n\r\nimport org.sidequest.parley.entity.ChatRoomEntity;\r\nimport org.springframework.data.jpa.repository.JpaRepository;\r\nimport org.springframework.stereotype.Repository;\r\n\r\n@Repository // This is an addition to try the mapper\r\npublic interface ChatRoomRepository extends JpaRepository<ChatRoomEntity, Long> {\r\n\r\n}",
              "methods": [],
              "businessRules": [],
              "relatedClasses": [],
              "dependencies": [
                "Spring Framework"
              ]
            },
            {
              "name": "EnrollmentRepository",
              "path": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-service-jpa\\src\\main\\java\\org\\sidequest\\parley\\repository\\EnrollmentRepository.java",
              "type": "interface",
              "imports": [
                "org.sidequest.parley.entity.EnrollmentEntity",
                "org.springframework.data.jpa.repository.JpaRepository",
                "org.springframework.stereotype.Repository",
                "java.util.Optional",
                "java.util.Set"
              ],
              "annotations": [
                "@Repository"
              ],
              "content": "package org.sidequest.parley.repository;\r\n\r\nimport org.sidequest.parley.entity.EnrollmentEntity;\r\nimport org.springframework.data.jpa.repository.JpaRepository;\r\nimport org.springframework.stereotype.Repository;\r\n\r\nimport java.util.Optional;\r\nimport java.util.Set;\r\n\r\n@Repository\r\npublic interface EnrollmentRepository extends JpaRepository<EnrollmentEntity, Long> {\r\n    Optional<EnrollmentEntity> findByChatroomIdAndChatuserId(Long chatroomId, Long userId);\r\n\r\n    Set<EnrollmentEntity> findByChatroomId(Long chatroomId);\r\n\r\n    void deleteByChatroomId(Long chatRoomId);\r\n\r\n    void deleteByChatroomIdAndChatuserId(Long chatRoomId, Long userId);\r\n\r\n    boolean existsByChatroomIdAndChatuserId(Long chatRoomId, Long userId);\r\n\r\n    Set<EnrollmentEntity> findAllByChatuserId(Long userId);\r\n}\r\n",
              "methods": [
                {
                  "name": "findByChatroomIdAndChatuserId",
                  "returnType": "Optional<EnrollmentEntity>",
                  "parameters": [
                    "Long chatroomId",
                    "Long userId"
                  ],
                  "annotations": [
                    "@Repository"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "findByChatroomId",
                  "returnType": "Set<EnrollmentEntity>",
                  "parameters": [
                    "Long chatroomId"
                  ],
                  "annotations": [
                    "@Repository"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "deleteByChatroomId",
                  "returnType": "void",
                  "parameters": [
                    "Long chatRoomId"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "deleteByChatroomIdAndChatuserId",
                  "returnType": "void",
                  "parameters": [
                    "Long chatRoomId",
                    "Long userId"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "existsByChatroomIdAndChatuserId",
                  "returnType": "boolean",
                  "parameters": [
                    "Long chatRoomId",
                    "Long userId"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "findAllByChatuserId",
                  "returnType": "Set<EnrollmentEntity>",
                  "parameters": [
                    "Long userId"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                }
              ],
              "businessRules": [],
              "relatedClasses": [],
              "dependencies": [
                "Spring Framework"
              ]
            },
            {
              "name": "UserRepository",
              "path": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-service-jpa\\src\\main\\java\\org\\sidequest\\parley\\repository\\UserRepository.java",
              "type": "interface",
              "imports": [
                "org.sidequest.parley.entity.UserEntity",
                "org.springframework.data.jpa.repository.JpaRepository",
                "org.springframework.data.jpa.repository.Modifying",
                "org.springframework.data.jpa.repository.Query",
                "org.springframework.data.repository.query.Param",
                "org.springframework.stereotype.Repository",
                "java.time.OffsetDateTime",
                "java.util.Optional"
              ],
              "annotations": [
                "@Repository",
                "@Modifying",
                "@Query(\"UPDATE UserEntity u SET u.passwordResetToken = :token, u.passwordResetTokenExpiration = :expiration WHERE u.email = :email\")",
                "@Param(\"email\")",
                "@Param(\"token\")",
                "@Param(\"expiration\")",
                "@Modifying",
                "@Query(\"UPDATE UserEntity u SET u.magic = :password, u.passwordResetToken = NULL, u.passwordResetTokenExpiration = NULL WHERE u.id = :userId\")",
                "@Param(\"userId\")",
                "@Param(\"password\")"
              ],
              "content": "package org.sidequest.parley.repository;\r\n\r\nimport org.sidequest.parley.entity.UserEntity;\r\nimport org.springframework.data.jpa.repository.JpaRepository;\r\nimport org.springframework.data.jpa.repository.Modifying;\r\nimport org.springframework.data.jpa.repository.Query;\r\nimport org.springframework.data.repository.query.Param;\r\nimport org.springframework.stereotype.Repository;\r\n\r\nimport java.time.OffsetDateTime;\r\nimport java.util.Optional;\r\n\r\n@Repository // This is an addition to try the mapper\r\npublic interface UserRepository extends JpaRepository<UserEntity, Long> {\r\n    Optional<UserEntity> findByName(String name);\r\n\r\n    boolean existsByName(String name);\r\n\r\n    void deleteByName(String name);\r\n\r\n    // New methods for password reset functionality\r\n    Optional<UserEntity> findByEmail(String email);\r\n\r\n    @Modifying\r\n    @Query(\"UPDATE UserEntity u SET u.passwordResetToken = :token, u.passwordResetTokenExpiration = :expiration WHERE u.email = :email\")\r\n    void updatePasswordResetToken(@Param(\"email\") String email, @Param(\"token\") String token, @Param(\"expiration\") OffsetDateTime expiration);\r\n\r\n    Optional<UserEntity> findByPasswordResetToken(String token);\r\n\r\n    @Modifying\r\n    @Query(\"UPDATE UserEntity u SET u.magic = :password, u.passwordResetToken = NULL, u.passwordResetTokenExpiration = NULL WHERE u.id = :userId\")\r\n    void updatePassword(@Param(\"userId\") Long userId, @Param(\"password\") String password);\r\n\r\n    boolean existsByEmail(String email);\r\n}\r\n",
              "methods": [
                {
                  "name": "findByName",
                  "returnType": "Optional<UserEntity>",
                  "parameters": [
                    "String name"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "existsByName",
                  "returnType": "boolean",
                  "parameters": [
                    "String name"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "deleteByName",
                  "returnType": "void",
                  "parameters": [
                    "String name"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "findByEmail",
                  "returnType": "New methods for password reset functionality\r\n    Optional<UserEntity>",
                  "parameters": [
                    "String email"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "findByPasswordResetToken",
                  "returnType": "Optional<UserEntity>",
                  "parameters": [
                    "String token"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "existsByEmail",
                  "returnType": "boolean",
                  "parameters": [
                    "String email"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                }
              ],
              "businessRules": [],
              "relatedClasses": [],
              "dependencies": [
                "Spring Framework"
              ]
            }
          ]
        },
        {
          "name": "org.sidequest.parley.mapper",
          "classes": [
            {
              "name": "ChatMessageMapper",
              "path": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-service-jpa\\src\\main\\java\\org\\sidequest\\parley\\mapper\\ChatMessageMapper.java",
              "type": "interface",
              "imports": [
                "org.mapstruct.AfterMapping",
                "org.mapstruct.Mapper",
                "org.mapstruct.MappingTarget",
                "org.mapstruct.factory.Mappers",
                "org.sidequest.parley.entity.ChatMessageEntity",
                "org.sidequest.parley.model.ChatMessage",
                "java.time.OffsetDateTime",
                "java.time.ZoneId",
                "java.time.ZoneOffset"
              ],
              "annotations": [
                "@Mapper(uses = {UserMapper.class, ChatRoomMapper.class})",
                "@Mapper",
                "@Mapping(target = \"id\", source = \"id\")",
                "@Mapping(target = \"chatRoom\", source = \"chatRoom\")",
                "@Mapping(target = \"content\", source = \"content\")",
                "@Mapping(target = \"timestamp\", ignore = true)",
                "@Mapping(target = \"user\", source = \"user\")",
                "@Mapping(target = \"id\", source = \"id\")",
                "@Mapping(target = \"chatRoom\", source = \"chatRoom\")",
                "@Mapping(target = \"content\", source = \"content\")",
                "@Mapping(target = \"timestamp\", ignore = true)",
                "@Mapping(target = \"user\", source = \"user\")",
                "@AfterMapping",
                "@MappingTarget",
                "@AfterMapping",
                "@MappingTarget"
              ],
              "content": "package org.sidequest.parley.mapper;\r\n\r\nimport org.mapstruct.AfterMapping;\r\nimport org.mapstruct.Mapper;\r\nimport org.mapstruct.MappingTarget;\r\nimport org.mapstruct.factory.Mappers;\r\nimport org.sidequest.parley.entity.ChatMessageEntity;\r\nimport org.sidequest.parley.model.ChatMessage;\r\n\r\nimport java.time.OffsetDateTime;\r\nimport java.time.ZoneId;\r\nimport java.time.ZoneOffset;\r\n\r\n\r\n//@Mapper(uses = {UserMapper.class, ChatRoomMapper.class})\r\n@Mapper\r\npublic interface ChatMessageMapper {\r\n    ChatMessageMapper INSTANCE = Mappers.getMapper(ChatMessageMapper.class);\r\n\r\n    //    @Mapping(target = \"id\", source = \"id\")\r\n//    @Mapping(target = \"chatRoom\", source = \"chatRoom\")\r\n//    @Mapping(target = \"content\", source = \"content\")\r\n//    @Mapping(target = \"timestamp\", ignore = true)\r\n//    @Mapping(target = \"user\", source = \"user\")\r\n    ChatMessageEntity toEntity(ChatMessage chatMessage);\r\n\r\n    //    @Mapping(target = \"id\", source = \"id\")\r\n//    @Mapping(target = \"chatRoom\", source = \"chatRoom\")\r\n//    @Mapping(target = \"content\", source = \"content\")\r\n//    @Mapping(target = \"timestamp\", ignore = true)\r\n//    @Mapping(target = \"user\", source = \"user\")\r\n    ChatMessage toModel(ChatMessageEntity chatMessageEntity);\r\n\r\n    @AfterMapping\r\n    default void convertUtcToLocalTime(@MappingTarget ChatMessage chatMessage, ChatMessageEntity chatMessageEntity) {\r\n        ZoneId userZoneId = ZoneId.of(chatMessage.getUser().getTimezone());\r\n        OffsetDateTime localTime = chatMessageEntity.getTimestamp().atZoneSameInstant(userZoneId).toOffsetDateTime();\r\n        chatMessage.setTimestamp(localTime);\r\n    }\r\n\r\n    @AfterMapping\r\n    default void convertLocalTimeToUtc(@MappingTarget ChatMessageEntity chatMessageEntity, ChatMessage chatMessage) {\r\n        ZoneId userZoneId = ZoneId.of(chatMessage.getUser().getTimezone());\r\n        OffsetDateTime utcTime = chatMessage.getTimestamp().atZoneSameInstant(ZoneOffset.UTC).toOffsetDateTime();\r\n        chatMessageEntity.setTimestamp(utcTime);\r\n    }\r\n\r\n}",
              "methods": [
                {
                  "name": "toEntity",
                  "returnType": "ChatMessageEntity",
                  "parameters": [
                    "ChatMessage chatMessage"
                  ],
                  "annotations": [
                    "@Mapping(target = \"content\", source = \"content\")",
                    "@Mapping(target = \"timestamp\", ignore = true)",
                    "@Mapping(target = \"user\", source = \"user\")"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "toModel",
                  "returnType": "ChatMessage",
                  "parameters": [
                    "ChatMessageEntity chatMessageEntity"
                  ],
                  "annotations": [
                    "@Mapping(target = \"content\", source = \"content\")",
                    "@Mapping(target = \"timestamp\", ignore = true)",
                    "@Mapping(target = \"user\", source = \"user\")"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "convertUtcToLocalTime",
                  "returnType": "AfterMapping\r\n    default void",
                  "parameters": [
                    "@MappingTarget ChatMessage chatMessage",
                    "ChatMessageEntity chatMessageEntity"
                  ],
                  "annotations": [
                    "@Mapping(target = \"timestamp\", ignore = true)",
                    "@Mapping(target = \"user\", source = \"user\")"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "convertLocalTimeToUtc",
                  "returnType": "AfterMapping\r\n    default void",
                  "parameters": [
                    "@MappingTarget ChatMessageEntity chatMessageEntity",
                    "ChatMessage chatMessage"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                }
              ],
              "businessRules": [],
              "relatedClasses": [],
              "dependencies": []
            },
            {
              "name": "ChatRoomMapper",
              "path": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-service-jpa\\src\\main\\java\\org\\sidequest\\parley\\mapper\\ChatRoomMapper.java",
              "type": "interface",
              "imports": [
                "org.mapstruct.Mapper",
                "org.mapstruct.Mapping",
                "org.mapstruct.factory.Mappers",
                "org.sidequest.parley.entity.ChatRoomEntity",
                "org.sidequest.parley.model.ChatRoom"
              ],
              "annotations": [
                "@Mapper(uses = {UserMapper.class, EnrollmentMapper.class})",
                "@Mapper",
                "@Mapping(source = \"id\", target = \"chatRoomId\")",
                "@Mapping(source = \"chatRoomId\", target = \"id\")"
              ],
              "content": "package org.sidequest.parley.mapper;\r\n\r\nimport org.mapstruct.Mapper;\r\nimport org.mapstruct.Mapping;\r\nimport org.mapstruct.factory.Mappers;\r\nimport org.sidequest.parley.entity.ChatRoomEntity;\r\nimport org.sidequest.parley.model.ChatRoom;\r\n\r\n\r\n//@Mapper(uses = {UserMapper.class, EnrollmentMapper.class})\r\n@Mapper\r\npublic interface ChatRoomMapper {\r\n\r\n    ChatRoomMapper INSTANCE = Mappers.getMapper(ChatRoomMapper.class);\r\n\r\n    @Mapping(source = \"id\", target = \"chatRoomId\")\r\n        // This is the only mapping that is different from the default\r\n    ChatRoom toModel(ChatRoomEntity entity);\r\n\r\n    @Mapping(source = \"chatRoomId\", target = \"id\")\r\n        // This is the only mapping that is different from the default\r\n    ChatRoomEntity toEntity(ChatRoom model);\r\n\r\n\r\n}",
              "methods": [
                {
                  "name": "toModel",
                  "returnType": "This is the only mapping that is different from the default\r\n    ChatRoom",
                  "parameters": [
                    "ChatRoomEntity entity"
                  ],
                  "annotations": [
                    "@Mapper",
                    "@Mapping(source = \"id\", target = \"chatRoomId\")"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "toEntity",
                  "returnType": "This is the only mapping that is different from the default\r\n    ChatRoomEntity",
                  "parameters": [
                    "ChatRoom model"
                  ],
                  "annotations": [
                    "@Mapping(source = \"chatRoomId\", target = \"id\")"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                }
              ],
              "businessRules": [],
              "relatedClasses": [],
              "dependencies": []
            },
            {
              "name": "EnrollmentMapper",
              "path": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-service-jpa\\src\\main\\java\\org\\sidequest\\parley\\mapper\\EnrollmentMapper.java",
              "type": "interface",
              "imports": [
                "org.mapstruct.Mapper",
                "org.mapstruct.Mapping",
                "org.mapstruct.factory.Mappers",
                "org.sidequest.parley.entity.EnrollmentEntity",
                "org.sidequest.parley.model.Enrollment"
              ],
              "annotations": [
                "@Mapper",
                "@Mapping(source = \"user.id\", target = \"userId\")",
                "@Mapping(source = \"chatroom.id\", target = \"chatRoomId\")",
                "@Mapping(source = \"userId\", target = \"user.id\")",
                "@Mapping(source = \"chatRoomId\", target = \"chatroom.id\")"
              ],
              "content": "package org.sidequest.parley.mapper;\r\n\r\nimport org.mapstruct.Mapper;\r\nimport org.mapstruct.Mapping;\r\nimport org.mapstruct.factory.Mappers;\r\nimport org.sidequest.parley.entity.EnrollmentEntity;\r\nimport org.sidequest.parley.model.Enrollment;\r\n\r\n@Mapper\r\npublic interface EnrollmentMapper {\r\n\r\n    EnrollmentMapper INSTANCE = Mappers.getMapper(EnrollmentMapper.class);\r\n\r\n    //This is the only mapping that is different from the default\r\n    @Mapping(source = \"user.id\", target = \"userId\")\r\n    @Mapping(source = \"chatroom.id\", target = \"chatRoomId\")\r\n    Enrollment toModel(EnrollmentEntity entity);\r\n\r\n    //This is the only mapping that is different from the default\r\n    @Mapping(source = \"userId\", target = \"user.id\")\r\n    @Mapping(source = \"chatRoomId\", target = \"chatroom.id\")\r\n    EnrollmentEntity toEntity(Enrollment model);\r\n}\r\n",
              "methods": [
                {
                  "name": "toModel",
                  "returnType": "Enrollment",
                  "parameters": [
                    "EnrollmentEntity entity"
                  ],
                  "annotations": [
                    "@Mapping(source = \"user.id\", target = \"userId\")",
                    "@Mapping(source = \"chatroom.id\", target = \"chatRoomId\")"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "toEntity",
                  "returnType": "EnrollmentEntity",
                  "parameters": [
                    "Enrollment model"
                  ],
                  "annotations": [
                    "@Mapping(source = \"userId\", target = \"user.id\")",
                    "@Mapping(source = \"chatRoomId\", target = \"chatroom.id\")"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                }
              ],
              "businessRules": [],
              "relatedClasses": [],
              "dependencies": []
            },
            {
              "name": "UserMapper",
              "path": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-service-jpa\\src\\main\\java\\org\\sidequest\\parley\\mapper\\UserMapper.java",
              "type": "interface",
              "imports": [
                "org.mapstruct.Mapper",
                "org.mapstruct.Mapping",
                "org.mapstruct.factory.Mappers",
                "org.sidequest.parley.entity.UserEntity",
                "org.sidequest.parley.model.User",
                "org.sidequest.parley.util.TimeHelper",
                "java.time.OffsetDateTime",
                "java.time.ZoneId"
              ],
              "annotations": [
                "@Mapper",
                "@param",
                "@return",
                "@Mapping(target = \"id\", source = \"id\")",
                "@Mapping(target = \"name\", source = \"name\")",
                "@Mapping(source = \"lastPostedMessageDateTime\", target = \"lastPostedMessageDateTime\")",
                "@Mapping(target = \"lastPostedMessageDateTime\", expression = \"java(convertToUtc(user.getLastPostedMessageDateTime()",
                "@Mapping(target = \"timezone\", source = \"timezone\")",
                "@Mapping(target = \"createdAt\", ignore = true)",
                "@Mapping(target = \"updatedAt\", ignore = true)",
                "@Mapping(target = \"email\", source = \"email\")",
                "@Mapping(target = \"passwordResetToken\", source = \"passwordResetToken\")",
                "@Mapping(target = \"passwordResetTokenExpiration\", source = \"passwordResetTokenExpiration\")",
                "@param",
                "@return",
                "@Mapping(target = \"id\", source = \"id\")",
                "@Mapping(target = \"name\", source = \"name\")",
                "@Mapping(source = \"lastPostedMessageDateTime\", target = \"lastPostedMessageDateTime\")",
                "@Mapping(target = \"lastPostedMessageDateTime\", expression = \"java(convertToLocalTime(userEntity.getLastPostedMessageDateTime()",
                "@Mapping(target = \"timezone\", source = \"timezone\")",
                "@Mapping(target = \"email\", source = \"email\")",
                "@Mapping(target = \"passwordResetToken\", source = \"passwordResetToken\")",
                "@Mapping(target = \"passwordResetTokenExpiration\", source = \"passwordResetTokenExpiration\")"
              ],
              "content": "package org.sidequest.parley.mapper;\r\n\r\nimport org.mapstruct.Mapper;\r\nimport org.mapstruct.Mapping;\r\nimport org.mapstruct.factory.Mappers;\r\nimport org.sidequest.parley.entity.UserEntity;\r\nimport org.sidequest.parley.model.User;\r\nimport org.sidequest.parley.util.TimeHelper;\r\n\r\nimport java.time.OffsetDateTime;\r\nimport java.time.ZoneId;\r\n\r\n/**\r\n * UserMapper is an interface that provides methods to map between User and UserEntity objects.\r\n * It uses the MapStruct library to generate the implementation at compile time.\r\n */\r\n@Mapper\r\npublic interface UserMapper {\r\n    UserMapper INSTANCE = Mappers.getMapper(UserMapper.class);\r\n\r\n    /**\r\n     * Maps a User model object to a UserEntity object.\r\n     *\r\n     * @param user the User model object to be mapped\r\n     * @return the mapped UserEntity object\r\n     */\r\n    @Mapping(target = \"id\", source = \"id\")\r\n    @Mapping(target = \"name\", source = \"name\")\r\n    //  @Mapping(source = \"lastPostedMessageDateTime\", target = \"lastPostedMessageDateTime\")\r\n    @Mapping(target = \"lastPostedMessageDateTime\", expression = \"java(convertToUtc(user.getLastPostedMessageDateTime()))\")\r\n    @Mapping(target = \"timezone\", source = \"timezone\")\r\n    @Mapping(target = \"createdAt\", ignore = true)\r\n    @Mapping(target = \"updatedAt\", ignore = true)\r\n    @Mapping(target = \"email\", source = \"email\")\r\n    @Mapping(target = \"passwordResetToken\", source = \"passwordResetToken\")\r\n    @Mapping(target = \"passwordResetTokenExpiration\", source = \"passwordResetTokenExpiration\")\r\n    UserEntity toEntity(User user);\r\n\r\n    /**\r\n     * Maps a UserEntity object to a User model object.\r\n     *\r\n     * @param userEntity the UserEntity object to be mapped\r\n     * @return the mapped User model object\r\n     */\r\n    @Mapping(target = \"id\", source = \"id\")\r\n    @Mapping(target = \"name\", source = \"name\")\r\n    //@Mapping(source = \"lastPostedMessageDateTime\", target = \"lastPostedMessageDateTime\")\r\n    @Mapping(target = \"lastPostedMessageDateTime\", expression = \"java(convertToLocalTime(userEntity.getLastPostedMessageDateTime(), userEntity.getTimezone()))\")\r\n    @Mapping(target = \"timezone\", source = \"timezone\")\r\n    @Mapping(target = \"email\", source = \"email\")\r\n    @Mapping(target = \"passwordResetToken\", source = \"passwordResetToken\")\r\n    @Mapping(target = \"passwordResetTokenExpiration\", source = \"passwordResetTokenExpiration\")\r\n    // Add this\r\n    User toModel(UserEntity userEntity);\r\n\r\n\r\n    default OffsetDateTime convertToUtc(OffsetDateTime localDateTime) {\r\n        return TimeHelper.toUtc(localDateTime);\r\n    }\r\n\r\n    default OffsetDateTime convertToLocalTime(OffsetDateTime utcTime, String timezone) {\r\n        if (utcTime == null) {\r\n            return null;\r\n        }\r\n        return TimeHelper.fromUtc(utcTime, ZoneId.of(timezone));\r\n    }\r\n}",
              "methods": [
                {
                  "name": "toEntity",
                  "returnType": "UserEntity",
                  "parameters": [
                    "User user"
                  ],
                  "annotations": [
                    "@Mapping(target = \"passwordResetToken\", source = \"passwordResetToken\")",
                    "@Mapping(target = \"passwordResetTokenExpiration\", source = \"passwordResetTokenExpiration\")"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "toModel",
                  "returnType": "Add this\r\n    User",
                  "parameters": [
                    "UserEntity userEntity"
                  ],
                  "annotations": [
                    "@Mapping(target = \"passwordResetToken\", source = \"passwordResetToken\")",
                    "@Mapping(target = \"passwordResetTokenExpiration\", source = \"passwordResetTokenExpiration\")"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "convertToUtc",
                  "returnType": "default OffsetDateTime",
                  "parameters": [
                    "OffsetDateTime localDateTime"
                  ],
                  "annotations": [
                    "@Mapping(target = \"passwordResetTokenExpiration\", source = \"passwordResetTokenExpiration\")"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "convertToLocalTime",
                  "returnType": "default OffsetDateTime",
                  "parameters": [
                    "OffsetDateTime utcTime",
                    "String timezone"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "if",
                  "returnType": "",
                  "parameters": [
                    "utcTime == null"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                }
              ],
              "businessRules": [],
              "relatedClasses": [],
              "dependencies": []
            }
          ]
        },
        {
          "name": "org.sidequest.parley.entity",
          "classes": [
            {
              "name": "ChatMessageEntity",
              "path": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-service-jpa\\src\\main\\java\\org\\sidequest\\parley\\entity\\ChatMessageEntity.java",
              "type": "class",
              "imports": [
                "jakarta.persistence.*",
                "lombok.Getter",
                "lombok.Setter",
                "org.springframework.format.annotation.DateTimeFormat",
                "java.time.OffsetDateTime"
              ],
              "annotations": [
                "@Entity(name = \"ChatMessageEntity\")",
                "@Getter",
                "@Setter",
                "@Table(name = \"chatmessages\")",
                "@Id",
                "@GeneratedValue(strategy = GenerationType.IDENTITY)",
                "@ManyToOne(fetch = FetchType.LAZY)",
                "@JoinColumn(name = \"chatrooms_id\", nullable = false)",
                "@DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME)",
                "@ManyToOne(fetch = FetchType.LAZY)",
                "@JoinColumn(name = \"chatusers_id\", nullable = false)"
              ],
              "content": "package org.sidequest.parley.entity;\r\n\r\nimport jakarta.persistence.*;\r\nimport lombok.Getter;\r\nimport lombok.Setter;\r\nimport org.springframework.format.annotation.DateTimeFormat;\r\n\r\nimport java.time.OffsetDateTime;\r\n\r\n@Entity(name = \"ChatMessageEntity\")\r\n@Getter\r\n@Setter\r\n@Table(name = \"chatmessages\")\r\npublic class ChatMessageEntity {\r\n    @Id\r\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\r\n    private Long id;\r\n\r\n    @ManyToOne(fetch = FetchType.LAZY)\r\n    @JoinColumn(name = \"chatrooms_id\", nullable = false)\r\n    private ChatRoomEntity chatRoom;\r\n\r\n    private String content;\r\n\r\n    private String screenEffect;\r\n\r\n    private String textEffect;\r\n\r\n    @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME)\r\n    private OffsetDateTime timestamp;\r\n\r\n    @ManyToOne(fetch = FetchType.LAZY)\r\n    @JoinColumn(name = \"chatusers_id\", nullable = false)\r\n    private UserEntity user;\r\n\r\n}\r\n",
              "methods": [],
              "businessRules": [],
              "relatedClasses": [],
              "dependencies": [
                "JPA"
              ]
            },
            {
              "name": "ChatRoomEntity",
              "path": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-service-jpa\\src\\main\\java\\org\\sidequest\\parley\\entity\\ChatRoomEntity.java",
              "type": "class",
              "imports": [
                "jakarta.persistence.*",
                "lombok.Getter",
                "lombok.Setter",
                "java.util.HashSet",
                "java.util.Set"
              ],
              "annotations": [
                "@Entity(name = \"ChatRoomEntity\")",
                "@Getter",
                "@Setter",
                "@Table(name = \"chatrooms\")",
                "@Id",
                "@GeneratedValue(strategy = GenerationType.IDENTITY)",
                "@OneToMany(mappedBy = \"chatroom\", cascade = CascadeType.ALL, orphanRemoval = true)",
                "@OneToOne",
                "@ManyToOne(fetch = FetchType.LAZY)",
                "@JoinColumn(name = \"chatmessages_id\")",
                "@Override"
              ],
              "content": "package org.sidequest.parley.entity;\r\n\r\nimport jakarta.persistence.*;\r\nimport lombok.Getter;\r\nimport lombok.Setter;\r\n\r\nimport java.util.HashSet;\r\nimport java.util.Set;\r\n\r\n@Entity(name = \"ChatRoomEntity\")\r\n@Getter\r\n@Setter\r\n@Table(name = \"chatrooms\")\r\npublic class ChatRoomEntity {\r\n\r\n    @Id\r\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\r\n    private Long id;\r\n\r\n    @OneToMany(mappedBy = \"chatroom\", cascade = CascadeType.ALL, orphanRemoval = true)\r\n    private Set<EnrollmentEntity> enrollments = new HashSet<>();\r\n\r\n    @OneToOne\r\n    private UserEntity moderator;\r\n\r\n    @ManyToOne(fetch = FetchType.LAZY)\r\n    @JoinColumn(name = \"chatmessages_id\")\r\n    private ChatMessageEntity chatMessage;\r\n\r\n    private String name;\r\n\r\n    private String iconPath;\r\n\r\n    // Constructors, getters, setters, and toString method\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"ChatRoomEntity{\" +\r\n                \"id=\" + id +\r\n                \", name='\" + name + '\\'' +\r\n                \", iconPath='\" + iconPath + '\\'' +\r\n                '}';\r\n    }\r\n\r\n}\r\n",
              "methods": [
                {
                  "name": "toString",
                  "returnType": "Override\r\n    public String",
                  "parameters": [],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                }
              ],
              "businessRules": [],
              "relatedClasses": [],
              "dependencies": [
                "JPA"
              ]
            },
            {
              "name": "EnrollmentEntity",
              "path": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-service-jpa\\src\\main\\java\\org\\sidequest\\parley\\entity\\EnrollmentEntity.java",
              "type": "class",
              "imports": [
                "jakarta.persistence.*",
                "lombok.Getter",
                "lombok.Setter"
              ],
              "annotations": [
                "@Getter",
                "@Setter",
                "@Entity(name = \"EnrollmentEntity\")",
                "@Table(name = \"chatrooms_chatusers\")",
                "@Id",
                "@GeneratedValue(strategy = GenerationType.IDENTITY)",
                "@ManyToOne",
                "@JoinColumn(name = \"chatrooms_id\")",
                "@ManyToOne",
                "@JoinColumn(name = \"chatusers_id\")",
                "@Override"
              ],
              "content": "package org.sidequest.parley.entity;\r\n\r\nimport jakarta.persistence.*;\r\nimport lombok.Getter;\r\nimport lombok.Setter;\r\n\r\n@Getter\r\n@Setter\r\n@Entity(name = \"EnrollmentEntity\")\r\n@Table(name = \"chatrooms_chatusers\")\r\npublic class EnrollmentEntity {\r\n\r\n    @Id\r\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\r\n    private Long id;\r\n\r\n    @ManyToOne\r\n    @JoinColumn(name = \"chatrooms_id\")\r\n    private ChatRoomEntity chatroom;\r\n\r\n    @ManyToOne\r\n    @JoinColumn(name = \"chatusers_id\")\r\n    private UserEntity chatuser;\r\n\r\n    // Constructors, getters, setters, and toString method\r\n\r\n    // Default constructor for JPA\r\n    public EnrollmentEntity() {\r\n    }\r\n\r\n    // Convenience constructor\r\n    public EnrollmentEntity(ChatRoomEntity chatroom, UserEntity user) {\r\n        this.chatroom = chatroom;\r\n        this.chatuser = user;\r\n    }\r\n\r\n    // toString method to help with debugging and logging\r\n    @Override\r\n    public String toString() {\r\n        return \"EnrollmentEntity{\" +\r\n                \"id=\" + id +\r\n                \", chatroom=\" + (chatroom != null ? chatroom.getName() : \"null\") + // Safely call getName if chatroom is not null\r\n                \", user=\" + (chatuser != null ? chatuser.getName() : \"null\") + // Safely call getUsername if user is not null\r\n                '}';\r\n    }\r\n\r\n    // The getUser method corrected to return the user properly\r\n    public UserEntity getUser() {\r\n        return chatuser;\r\n    }\r\n\r\n    // Setter method for user\r\n    public void setUser(UserEntity user) {\r\n        this.chatuser = user;\r\n    }\r\n}\r\n",
              "methods": [
                {
                  "name": "EnrollmentEntity",
                  "returnType": "Default constructor for JPA\r\n    public",
                  "parameters": [],
                  "annotations": [
                    "@ManyToOne",
                    "@JoinColumn(name = \"chatusers_id\")"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "EnrollmentEntity",
                  "returnType": "Convenience constructor\r\n    public",
                  "parameters": [
                    "ChatRoomEntity chatroom",
                    "UserEntity user"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "toString",
                  "returnType": "Override\r\n    public String",
                  "parameters": [],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "getUser",
                  "returnType": "The getUser method corrected to return the user properly\r\n    public UserEntity",
                  "parameters": [],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "setUser",
                  "returnType": "Setter method for user\r\n    public void",
                  "parameters": [
                    "UserEntity user"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                }
              ],
              "businessRules": [],
              "relatedClasses": [],
              "dependencies": [
                "JPA"
              ]
            },
            {
              "name": "UserEntity",
              "path": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-service-jpa\\src\\main\\java\\org\\sidequest\\parley\\entity\\UserEntity.java",
              "type": "class",
              "imports": [
                "jakarta.persistence.*",
                "lombok.Getter",
                "lombok.Setter",
                "org.springframework.data.annotation.CreatedDate",
                "org.springframework.data.annotation.LastModifiedDate",
                "org.springframework.format.annotation.DateTimeFormat",
                "org.springframework.security.core.GrantedAuthority",
                "org.springframework.security.core.authority.SimpleGrantedAuthority",
                "org.springframework.security.core.userdetails.UserDetails",
                "java.time.OffsetDateTime",
                "java.util.Collection",
                "java.util.Collections",
                "java.util.HashSet",
                "java.util.Set"
              ],
              "annotations": [
                "@Entity(name = \"UserEntity\")",
                "@Getter",
                "@Setter",
                "@Table(name = \"chatusers\")",
                "@Id",
                "@GeneratedValue(strategy = GenerationType.IDENTITY)",
                "@Column(name = \"name\", columnDefinition = \"VARCHAR(255)",
                "@Column(name = \"magic\", columnDefinition = \"VARCHAR(255)",
                "@Column(name = \"timezone\", columnDefinition = \"VARCHAR(255)",
                "@Column(name = \"email\", unique = true)",
                "@Column(name = \"passwordresettoken\")",
                "@Column(name = \"passwordresettokenexpiration\")",
                "@CreatedDate",
                "@Column(name = \"created\", nullable = false, updatable = false)",
                "@LastModifiedDate",
                "@Column(name = \"updated\")",
                "@Setter",
                "@DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME)",
                "@Column(name = \"last_posted_message_date_time\")",
                "@OneToMany(mappedBy = \"chatuser\", cascade = CascadeType.ALL, orphanRemoval = true)",
                "@Override",
                "@PrePersist",
                "@Override",
                "@Override",
                "@Override",
                "@Override",
                "@Override",
                "@Override",
                "@Override"
              ],
              "content": "package org.sidequest.parley.entity;\r\n\r\nimport jakarta.persistence.*;\r\nimport lombok.Getter;\r\nimport lombok.Setter;\r\nimport org.springframework.data.annotation.CreatedDate;\r\nimport org.springframework.data.annotation.LastModifiedDate;\r\nimport org.springframework.format.annotation.DateTimeFormat;\r\nimport org.springframework.security.core.GrantedAuthority;\r\nimport org.springframework.security.core.authority.SimpleGrantedAuthority;\r\nimport org.springframework.security.core.userdetails.UserDetails;\r\n\r\nimport java.time.OffsetDateTime;\r\nimport java.util.Collection;\r\nimport java.util.Collections;\r\nimport java.util.HashSet;\r\nimport java.util.Set;\r\n\r\n@Entity(name = \"UserEntity\")\r\n@Getter\r\n@Setter\r\n@Table(name = \"chatusers\")\r\npublic class UserEntity implements UserDetails {\r\n\r\n    @Id\r\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\r\n    private Long id;\r\n\r\n    @Column(name = \"name\", columnDefinition = \"VARCHAR(255)\")\r\n    private String name;\r\n\r\n    @Column(name = \"magic\", columnDefinition = \"VARCHAR(255)\")\r\n    private String magic;\r\n\r\n    private String avatarPath;\r\n\r\n    @Column(name = \"timezone\", columnDefinition = \"VARCHAR(255)\")\r\n    private String timezone;\r\n\r\n    @Column(name = \"email\", unique = true)\r\n    private String email;\r\n\r\n    @Column(name = \"passwordresettoken\")\r\n    private String passwordResetToken;\r\n\r\n    @Column(name = \"passwordresettokenexpiration\")\r\n    private OffsetDateTime passwordResetTokenExpiration;\r\n\r\n\r\n    @CreatedDate\r\n    @Column(name = \"created\", nullable = false, updatable = false)\r\n    private OffsetDateTime createdAt;\r\n\r\n    @LastModifiedDate\r\n    @Column(name = \"updated\")\r\n    private OffsetDateTime updatedAt;\r\n\r\n    @Setter\r\n    @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME)\r\n    @Column(name = \"last_posted_message_date_time\")\r\n    private OffsetDateTime lastPostedMessageDateTime;\r\n\r\n    // Define the relationship with EnrollmentEntity\r\n    @OneToMany(mappedBy = \"chatuser\", cascade = CascadeType.ALL, orphanRemoval = true)\r\n    private Set<EnrollmentEntity> enrollments = new HashSet<>();\r\n\r\n    // Constructors, getters, setters, and toString method\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"UserEntity{\" +\r\n                \"id=\" + id +\r\n                \", name='\" + name + '\\'' +\r\n                \", avatarPath='\" + avatarPath + '\\'' +\r\n                \", timezone='\" + timezone + '\\'' +\r\n                \", lastPostedMessageDateTime=\" + lastPostedMessageDateTime +\r\n                '}';\r\n    }\r\n\r\n    @PrePersist\r\n    protected void onCreate() {\r\n        createdAt = OffsetDateTime.now();\r\n    }\r\n\r\n    @Override\r\n    public Collection<? extends GrantedAuthority> getAuthorities() {\r\n        return Collections.singletonList(new SimpleGrantedAuthority(\"ROLE_USER\"));\r\n    }\r\n\r\n    @Override\r\n    public String getPassword() {\r\n        return magic; // using the 'magic' field as password\r\n    }\r\n\r\n    @Override\r\n    public String getUsername() {\r\n        return name;\r\n    }\r\n\r\n    @Override\r\n    public boolean isAccountNonExpired() {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public boolean isAccountNonLocked() {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public boolean isCredentialsNonExpired() {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public boolean isEnabled() {\r\n        return true;\r\n    }\r\n\r\n}\r\n",
              "methods": [
                {
                  "name": "toString",
                  "returnType": "Override\r\n    public String",
                  "parameters": [],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "onCreate",
                  "returnType": "PrePersist\r\n    protected void",
                  "parameters": [],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "getAuthorities",
                  "returnType": "extends GrantedAuthority>",
                  "parameters": [],
                  "annotations": [
                    "@PrePersist",
                    "@Override"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "getPassword",
                  "returnType": "Override\r\n    public String",
                  "parameters": [],
                  "annotations": [
                    "@Override"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "getUsername",
                  "returnType": "Override\r\n    public String",
                  "parameters": [],
                  "annotations": [
                    "@Override"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "isAccountNonExpired",
                  "returnType": "Override\r\n    public boolean",
                  "parameters": [],
                  "annotations": [
                    "@Override"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "isAccountNonLocked",
                  "returnType": "Override\r\n    public boolean",
                  "parameters": [],
                  "annotations": [
                    "@Override",
                    "@Override"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "isCredentialsNonExpired",
                  "returnType": "Override\r\n    public boolean",
                  "parameters": [],
                  "annotations": [
                    "@Override",
                    "@Override"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "isEnabled",
                  "returnType": "Override\r\n    public boolean",
                  "parameters": [],
                  "annotations": [
                    "@Override",
                    "@Override"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                }
              ],
              "businessRules": [],
              "relatedClasses": [
                "UserDetails",
                "GrantedAuthority"
              ],
              "dependencies": [
                "JPA"
              ]
            }
          ]
        },
        {
          "name": "org.sidequest.parley.config",
          "classes": [
            {
              "name": "DbConfig",
              "path": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-service-jpa\\src\\main\\java\\org\\sidequest\\parley\\config\\DbConfig.java",
              "type": "class",
              "imports": [
                "jakarta.persistence.EntityManagerFactory",
                "org.springframework.beans.factory.annotation.Autowired",
                "org.springframework.context.annotation.Bean",
                "org.springframework.context.annotation.Configuration",
                "org.springframework.core.env.Environment",
                "org.springframework.data.jpa.repository.config.EnableJpaRepositories",
                "org.springframework.jdbc.datasource.DriverManagerDataSource",
                "org.springframework.orm.jpa.JpaTransactionManager",
                "org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean",
                "org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter",
                "org.springframework.transaction.PlatformTransactionManager",
                "org.springframework.transaction.annotation.EnableTransactionManagement",
                "javax.sql.DataSource",
                "java.util.Properties"
              ],
              "annotations": [
                "@Configuration",
                "@EnableTransactionManagement",
                "@EnableJpaRepositories(basePackages = \"org.sidequest.parley.repository\")",
                "@Autowired",
                "@Bean",
                "@Bean",
                "@Bean"
              ],
              "content": "package org.sidequest.parley.config;\r\n\r\nimport jakarta.persistence.EntityManagerFactory;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.Configuration;\r\nimport org.springframework.core.env.Environment;\r\nimport org.springframework.data.jpa.repository.config.EnableJpaRepositories;\r\nimport org.springframework.jdbc.datasource.DriverManagerDataSource;\r\nimport org.springframework.orm.jpa.JpaTransactionManager;\r\nimport org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;\r\nimport org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter;\r\nimport org.springframework.transaction.PlatformTransactionManager;\r\nimport org.springframework.transaction.annotation.EnableTransactionManagement;\r\n\r\nimport javax.sql.DataSource;\r\nimport java.util.Properties;\r\n\r\n@Configuration\r\n@EnableTransactionManagement\r\n@EnableJpaRepositories(basePackages = \"org.sidequest.parley.repository\")\r\npublic class DbConfig {\r\n    @Autowired\r\n    Environment env;\r\n\r\n    @Bean\r\n    public DataSource dataSource() {\r\n        final DriverManagerDataSource dataSource = new DriverManagerDataSource();\r\n        dataSource.setDriverClassName(env.getProperty(\"spring.datasource.driver-class-name\"));\r\n        dataSource.setUrl(env.getProperty(\"spring.datasource.url\"));\r\n        dataSource.setUsername(env.getProperty(\"spring.datasource.username\"));\r\n        dataSource.setPassword(env.getProperty(\"spring.datasource.password\"));\r\n        return dataSource;\r\n    }\r\n\r\n    @Bean\r\n    public LocalContainerEntityManagerFactoryBean entityManagerFactory() {\r\n        LocalContainerEntityManagerFactoryBean em = new LocalContainerEntityManagerFactoryBean();\r\n        em.setDataSource(dataSource());\r\n        em.setPackagesToScan(\"org.sidequest.parley.entity\");\r\n\r\n        HibernateJpaVendorAdapter vendorAdapter = new HibernateJpaVendorAdapter();\r\n        vendorAdapter.setShowSql(true);\r\n        em.setJpaVendorAdapter(vendorAdapter);\r\n\r\n        Properties properties = new Properties();\r\n        properties.setProperty(\"hibernate.dialect\", env.getProperty(\"spring.jpa.properties.hibernate.dialect\"));\r\n        properties.setProperty(\"hibernate.hbm2ddl.auto\", env.getProperty(\"spring.jpa.hibernate.ddl-auto\"));\r\n        properties.setProperty(\"hibernate.show_sql\", env.getProperty(\"spring.jpa.show-sql\", \"true\"));\r\n        em.setJpaProperties(properties);\r\n\r\n        return em;\r\n    }\r\n\r\n    @Bean\r\n    public PlatformTransactionManager transactionManager(EntityManagerFactory entityManagerFactory) {\r\n        JpaTransactionManager transactionManager = new JpaTransactionManager();\r\n        transactionManager.setEntityManagerFactory(entityManagerFactory);\r\n        return transactionManager;\r\n    }\r\n}\r\n",
              "methods": [
                {
                  "name": "dataSource",
                  "returnType": "Bean\r\n    public DataSource",
                  "parameters": [],
                  "annotations": [
                    "@Configuration",
                    "@EnableTransactionManagement",
                    "@EnableJpaRepositories(basePackages = \"org.sidequest.parley.repository\")",
                    "@Autowired"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "DriverManagerDataSource",
                  "returnType": "new",
                  "parameters": [],
                  "annotations": [
                    "@Autowired",
                    "@Bean"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "entityManagerFactory",
                  "returnType": "Bean\r\n    public LocalContainerEntityManagerFactoryBean",
                  "parameters": [],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "LocalContainerEntityManagerFactoryBean",
                  "returnType": "new",
                  "parameters": [],
                  "annotations": [
                    "@Bean"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "HibernateJpaVendorAdapter",
                  "returnType": "new",
                  "parameters": [],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "Properties",
                  "returnType": "new",
                  "parameters": [],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "transactionManager",
                  "returnType": "Bean\r\n    public PlatformTransactionManager",
                  "parameters": [
                    "EntityManagerFactory entityManagerFactory"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "JpaTransactionManager",
                  "returnType": "new",
                  "parameters": [],
                  "annotations": [
                    "@Bean"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                }
              ],
              "businessRules": [],
              "relatedClasses": [],
              "dependencies": [
                "Spring Framework"
              ]
            },
            {
              "name": "OpenAPIConfig",
              "path": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-service-jpa\\src\\main\\java\\org\\sidequest\\parley\\config\\OpenAPIConfig.java",
              "type": "class",
              "imports": [
                "io.swagger.v3.oas.models.Components",
                "io.swagger.v3.oas.models.OpenAPI",
                "io.swagger.v3.oas.models.info.Info",
                "io.swagger.v3.oas.models.security.SecurityRequirement",
                "io.swagger.v3.oas.models.security.SecurityScheme",
                "io.swagger.v3.oas.models.servers.Server",
                "org.springframework.context.annotation.Bean",
                "org.springframework.context.annotation.Configuration",
                "java.util.logging.Logger"
              ],
              "annotations": [
                "@Configuration",
                "@Bean"
              ],
              "content": "package org.sidequest.parley.config;\r\n\r\nimport io.swagger.v3.oas.models.Components;\r\nimport io.swagger.v3.oas.models.OpenAPI;\r\nimport io.swagger.v3.oas.models.info.Info;\r\nimport io.swagger.v3.oas.models.security.SecurityRequirement;\r\nimport io.swagger.v3.oas.models.security.SecurityScheme;\r\nimport io.swagger.v3.oas.models.servers.Server;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.Configuration;\r\n\r\nimport java.util.logging.Logger;\r\n\r\n@Configuration\r\npublic class OpenAPIConfig {\r\n    private static final Logger log = Logger.getLogger(OpenAPIConfig.class.getName());\r\n\r\n    @Bean\r\n    public OpenAPI customizeOpenAPI() {\r\n        log.info(\"Initializing OpenAPI configuration\");\r\n        final String securitySchemeName = \"bearerAuth\";\r\n\r\n        OpenAPI openAPI = new OpenAPI()\r\n                .addServersItem(new Server().url(\"/parley/api\").description(\"Default Server\"))\r\n                .info(new Info()\r\n                        .title(\"Parley API\")\r\n                        .version(\"1.0.0\")\r\n                        .description(\"Chat application API\"))\r\n                .addSecurityItem(new SecurityRequirement().addList(securitySchemeName))\r\n                .components(new Components()\r\n                        .addSecuritySchemes(securitySchemeName,\r\n                                new SecurityScheme()\r\n                                        .name(securitySchemeName)\r\n                                        .type(SecurityScheme.Type.HTTP)\r\n                                        .scheme(\"bearer\")\r\n                                        .bearerFormat(\"JWT\")\r\n                                        .description(\"JWT Authorization header using Bearer scheme. Example: \\\"Bearer {token}\\\"\")));\r\n\r\n        log.info(\"OpenAPI configuration completed\");\r\n        return openAPI;\r\n    }\r\n}",
              "methods": [
                {
                  "name": "customizeOpenAPI",
                  "returnType": "Bean\r\n    public OpenAPI",
                  "parameters": [],
                  "annotations": [
                    "@Configuration"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                }
              ],
              "businessRules": [],
              "relatedClasses": [],
              "dependencies": []
            },
            {
              "name": "SecurityConfig",
              "path": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-service-jpa\\src\\main\\java\\org\\sidequest\\parley\\config\\SecurityConfig.java",
              "type": "class",
              "imports": [
                "lombok.RequiredArgsConstructor",
                "lombok.extern.slf4j.Slf4j",
                "org.sidequest.parley.security.JwtAuthenticationFilter",
                "org.springframework.context.annotation.Bean",
                "org.springframework.context.annotation.Configuration",
                "org.springframework.security.authentication.AuthenticationManager",
                "org.springframework.security.authentication.AuthenticationProvider",
                "org.springframework.security.authentication.dao.DaoAuthenticationProvider",
                "org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration",
                "org.springframework.security.config.annotation.web.builders.HttpSecurity",
                "org.springframework.security.config.annotation.web.configuration.EnableWebSecurity",
                "org.springframework.security.config.http.SessionCreationPolicy",
                "org.springframework.security.core.userdetails.UserDetailsService",
                "org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder",
                "org.springframework.security.crypto.password.PasswordEncoder",
                "org.springframework.security.web.SecurityFilterChain",
                "org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter",
                "java.util.Arrays"
              ],
              "annotations": [
                "@Slf4j",
                "@Configuration",
                "@EnableWebSecurity",
                "@RequiredArgsConstructor",
                "@Bean",
                "@Bean",
                "@Bean",
                "@Bean"
              ],
              "content": "package org.sidequest.parley.config;\r\n\r\nimport lombok.RequiredArgsConstructor;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.sidequest.parley.security.JwtAuthenticationFilter;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.Configuration;\r\nimport org.springframework.security.authentication.AuthenticationManager;\r\nimport org.springframework.security.authentication.AuthenticationProvider;\r\nimport org.springframework.security.authentication.dao.DaoAuthenticationProvider;\r\nimport org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;\r\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\r\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\r\nimport org.springframework.security.config.http.SessionCreationPolicy;\r\nimport org.springframework.security.core.userdetails.UserDetailsService;\r\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\r\nimport org.springframework.security.crypto.password.PasswordEncoder;\r\nimport org.springframework.security.web.SecurityFilterChain;\r\nimport org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;\r\n\r\nimport java.util.Arrays;\r\n\r\n@Slf4j\r\n@Configuration\r\n@EnableWebSecurity\r\n@RequiredArgsConstructor\r\npublic class SecurityConfig {\r\n    private final JwtAuthenticationFilter jwtAuthFilter;\r\n    private final UserDetailsService userDetailsService;\r\n\r\n    // Static initialization to test logging\r\n    static {\r\n        System.out.println(\"STATIC INIT: SecurityConfig is being loaded\");\r\n    }\r\n\r\n    private static final String[] TOMCAT_WHITE_LIST_URL = {\r\n            \"/webjars/**\",\r\n            \"META-INF/resources/webjars/\",\r\n            \"META-INF/resources/webjars/**\",\r\n            \"/resources/**\",\r\n            \"/static/**\",\r\n            \"/public/**\"\r\n    };\r\n\r\n    private static final String[] SWAGGER_WHITE_LIST_URL = {\r\n            \"/api/swagger-ui/index.html\",\r\n            \"/parley/api/api-docs/swagger-config\",\r\n            \"/parley/api/swagger-ui/**\",\r\n            \"/parley/api/v3/api-docs/**\",\r\n            \"/parley/api/swagger-resources/**\",\r\n            \"/parley/api/webjars/**\",\r\n            \"/swagger-ui/**\",\r\n            \"/v3/api-docs/**\"\r\n    };\r\n\r\n    private static final String[] PARLEY_WHITE_LIST_URL = {\r\n            \"/parley/api/auth/login\",\r\n            \"/parley/api/auth/signup\",\r\n            \"/parley/api/auth/signup/**\",\r\n            \"/parley/api/auth/password/reset\",\r\n            \"/parley/api/auth/password/reset/**\",\r\n            \"/auth/signup\",\r\n            \"/auth/login\",\r\n            \"/auth/logout\",\r\n            \"/auth/password/reset\",\r\n            \"/api/auth/signup\",\r\n            \"/api/auth/login\",\r\n            \"/api/auth/logout\",\r\n            \"/api/auth/password/reset\",\r\n            \"/parley/auth/login\",\r\n            \"/parley/auth/signup\",\r\n            \"/parley/signup\"\r\n    };\r\n\r\n    @Bean\r\n    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\r\n\r\n        // Multiple logging approaches\r\n        log.debug(\"Tomcat Whitelist URLs:\");\r\n        for (String url : TOMCAT_WHITE_LIST_URL) {\r\n            log.debug(\"  - {}\", url);\r\n        }\r\n\r\n        log.debug(\"Swagger Whitelist URLs:\");\r\n        for (String url : SWAGGER_WHITE_LIST_URL) {\r\n            log.debug(\"  - {}\", url);\r\n        }\r\n\r\n        log.debug(\"Parley Whitelist URLs:\");\r\n        for (String url : PARLEY_WHITE_LIST_URL) {\r\n            log.debug(\"  - {}\", url);\r\n        }\r\n\r\n        // Log the total number of whitelisted URLs\r\n        log.debug(\"Total Whitelisted URLs:\");\r\n        log.debug(\"  Tomcat URLs: {}\", TOMCAT_WHITE_LIST_URL.length);\r\n        log.debug(\"  Swagger URLs: {}\", SWAGGER_WHITE_LIST_URL.length);\r\n        log.debug(\"  Parley URLs: {}\", PARLEY_WHITE_LIST_URL.length);\r\n\r\n\r\n        System.out.println(\"SYSTEM OUT: Configuring SecurityFilterChain\");\r\n        System.err.println(\"SYSTEM ERR: Configuring SecurityFilterChain\");\r\n\r\n        log.error(\"ERROR LEVEL: Configuring SecurityFilterChain\");\r\n        log.warn(\"WARN LEVEL: Configuring SecurityFilterChain\");\r\n        log.info(\"INFO LEVEL: Configuring SecurityFilterChain\");\r\n        log.debug(\"DEBUG LEVEL: Configuring SecurityFilterChain\");\r\n        log.trace(\"TRACE LEVEL: Configuring SecurityFilterChain\");\r\n\r\n        log.debug(\"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\");\r\n        log.debug(\"~~~Configuring SecurityFilterChain~~~\");\r\n        log.debug(\"HTTP Security Configuration Details:\");\r\n        log.debug(\"HTTP Object: {}\", http);\r\n        log.debug(\"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\");\r\n\r\n        System.out.println(\"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\");\r\n        System.out.println(\"~~~Configuring SecurityFilterChain~~~\");\r\n        System.out.println(\"HTTP Security Configuration Details:\");\r\n        System.out.println(\"HTTP Object: \" + http);\r\n        System.out.println(\"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\");\r\n\r\n        http\r\n                .csrf(csrf -> {\r\n                    csrf.disable();\r\n                    log.debug(\"CSRF disabled\");\r\n                })\r\n                .authorizeHttpRequests(auth -> {\r\n                    try {\r\n                        auth\r\n                                .requestMatchers(\r\n                                        \"/v3/api-docs/**\",\r\n                                        \"/swagger-ui/**\",\r\n                                        \"/api-docs/**\",\r\n                                        \"/parley/api-docs/**\",\r\n                                        \"/parley/api/api-docs/**\",\r\n                                        \"/parley/api/swagger-ui/**\",\r\n                                        \"/parley/api/v3/api-docs/**\",\r\n                                        \"/parley/api/swagger-resources/**\",\r\n                                        \"/webjars/**\"\r\n                                ).permitAll()\r\n                                // Public endpoints\r\n                                .requestMatchers(\"/parley/api/auth/**\").permitAll()\r\n                                .requestMatchers(TOMCAT_WHITE_LIST_URL).permitAll()\r\n                                .requestMatchers(SWAGGER_WHITE_LIST_URL).permitAll()\r\n                                .requestMatchers(PARLEY_WHITE_LIST_URL).permitAll()\r\n                                .anyRequest()\r\n                                .authenticated();\r\n                        // Detailed logging of specific matcher configurations\r\n                        log.debug(\"Permitted Tomcat URLs: {}\", Arrays.toString(TOMCAT_WHITE_LIST_URL));\r\n                        log.debug(\"Permitted Swagger URLs: {}\", Arrays.toString(SWAGGER_WHITE_LIST_URL));\r\n                        log.debug(\"Permitted Parley URLs: {}\", Arrays.toString(PARLEY_WHITE_LIST_URL));\r\n                    } catch (Exception e) {\r\n                        log.error(\"Error configuring request authorization\", e);\r\n                        throw new RuntimeException(e);\r\n                    }\r\n                })\r\n                .sessionManagement(session -> {\r\n                    session.sessionCreationPolicy(SessionCreationPolicy.STATELESS);\r\n                    log.debug(\"Session management set to STATELESS\");\r\n                })\r\n                .authenticationProvider(authenticationProvider())\r\n                .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class);\r\n\r\n        log.debug(\"SecurityFilterChain configuration complete\");\r\n        return http.build();\r\n    }\r\n\r\n    @Bean\r\n    public AuthenticationProvider authenticationProvider() {\r\n        log.debug(\"Creating AuthenticationProvider\");\r\n        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();\r\n        authProvider.setUserDetailsService(userDetailsService);\r\n        authProvider.setPasswordEncoder(passwordEncoder());\r\n        log.debug(\"AuthenticationProvider created with UserDetailsService and PasswordEncoder\");\r\n        return authProvider;\r\n    }\r\n\r\n    @Bean\r\n    public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {\r\n        log.debug(\"Creating AuthenticationManager\");\r\n        return config.getAuthenticationManager();\r\n    }\r\n\r\n    @Bean\r\n    public PasswordEncoder passwordEncoder() {\r\n        log.debug(\"Creating BCryptPasswordEncoder\");\r\n        return new BCryptPasswordEncoder();\r\n    }\r\n}",
              "methods": [
                {
                  "name": "securityFilterChain",
                  "returnType": "Bean\r\n    public SecurityFilterChain",
                  "parameters": [
                    "HttpSecurity http"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": [
                    "Exception"
                  ]
                },
                {
                  "name": "for",
                  "returnType": "",
                  "parameters": [
                    "String url : TOMCAT_WHITE_LIST_URL"
                  ],
                  "annotations": [
                    "@Bean"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "for",
                  "returnType": "",
                  "parameters": [
                    "String url : SWAGGER_WHITE_LIST_URL"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "for",
                  "returnType": "",
                  "parameters": [
                    "String url : PARLEY_WHITE_LIST_URL"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "RuntimeException",
                  "returnType": "throw new",
                  "parameters": [
                    "e"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "authenticationProvider",
                  "returnType": "Bean\r\n    public AuthenticationProvider",
                  "parameters": [],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "DaoAuthenticationProvider",
                  "returnType": "new",
                  "parameters": [],
                  "annotations": [
                    "@Bean"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "authenticationManager",
                  "returnType": "Bean\r\n    public AuthenticationManager",
                  "parameters": [
                    "AuthenticationConfiguration config"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": [
                    "Exception"
                  ]
                },
                {
                  "name": "passwordEncoder",
                  "returnType": "Bean\r\n    public PasswordEncoder",
                  "parameters": [],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "BCryptPasswordEncoder",
                  "returnType": "return new",
                  "parameters": [],
                  "annotations": [
                    "@Bean"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                }
              ],
              "businessRules": [],
              "relatedClasses": [],
              "dependencies": []
            },
            {
              "name": "WebConfig",
              "path": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-service-jpa\\src\\main\\java\\org\\sidequest\\parley\\config\\WebConfig.java",
              "type": "class",
              "imports": [
                "org.springframework.context.annotation.Configuration",
                "org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry",
                "org.springframework.web.servlet.config.annotation.WebMvcConfigurer"
              ],
              "annotations": [
                "@Configuration",
                "@Override"
              ],
              "content": "package org.sidequest.parley.config;\r\n\r\nimport org.springframework.context.annotation.Configuration;\r\nimport org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;\r\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurer;\r\n\r\n@Configuration\r\npublic class WebConfig implements WebMvcConfigurer {\r\n\r\n    @Override\r\n    public void addResourceHandlers(ResourceHandlerRegistry registry) {\r\n        // Swagger UI resources\r\n        registry\r\n                .addResourceHandler(\"/swagger-ui/**\", \"/api/swagger-ui/**\")\r\n                .addResourceLocations(\"classpath:/META-INF/resources/webjars/swagger-ui/4.15.5/\")\r\n                .resourceChain(false);\r\n\r\n        // WebJars resources\r\n        registry\r\n                .addResourceHandler(\"/webjars/**\", \"/api/webjars/**\")\r\n                .addResourceLocations(\"classpath:/META-INF/resources/webjars/\")\r\n                .resourceChain(false);\r\n\r\n        // Other static resources\r\n        registry\r\n                .addResourceHandler(\"/**\")\r\n                .addResourceLocations(\r\n                        \"classpath:/META-INF/resources/\",\r\n                        \"classpath:/resources/\",\r\n                        \"classpath:/static/\",\r\n                        \"classpath:/public/\"\r\n                );\r\n    }\r\n}",
              "methods": [
                {
                  "name": "addResourceHandlers",
                  "returnType": "Override\r\n    public void",
                  "parameters": [
                    "ResourceHandlerRegistry registry"
                  ],
                  "annotations": [
                    "@Configuration"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                }
              ],
              "businessRules": [],
              "relatedClasses": [
                "WebMvcConfigurer"
              ],
              "dependencies": []
            }
          ]
        },
        {
          "name": "org.sidequest.parley.controller",
          "classes": [
            {
              "name": "AuthenticationController",
              "path": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-service-jpa\\src\\main\\java\\org\\sidequest\\parley\\controller\\AuthenticationController.java",
              "type": "class",
              "imports": [
                "org.sidequest.parley.api.AuthApi",
                "org.sidequest.parley.exception.ValidationException",
                "org.sidequest.parley.model.AuthRequest",
                "org.sidequest.parley.model.AuthResponse",
                "org.sidequest.parley.model.SignupRequest",
                "org.sidequest.parley.service.AuthenticationService",
                "org.springframework.beans.factory.annotation.Autowired",
                "org.springframework.http.ResponseEntity",
                "org.springframework.web.bind.annotation.RestController",
                "java.util.HashMap",
                "java.util.Map",
                "java.util.logging.Logger"
              ],
              "annotations": [
                "@RestController",
                "@Autowired",
                "@Override",
                "@Override"
              ],
              "content": "package org.sidequest.parley.controller;\r\n\r\nimport org.sidequest.parley.api.AuthApi;\r\nimport org.sidequest.parley.exception.ValidationException;\r\nimport org.sidequest.parley.model.AuthRequest;\r\nimport org.sidequest.parley.model.AuthResponse;\r\nimport org.sidequest.parley.model.SignupRequest;\r\nimport org.sidequest.parley.service.AuthenticationService;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.http.ResponseEntity;\r\nimport org.springframework.web.bind.annotation.RestController;\r\n\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\nimport java.util.logging.Logger;\r\n\r\n@RestController\r\npublic class AuthenticationController implements AuthApi {\r\n    private static final Logger log = Logger.getLogger(AuthenticationController.class.getName());\r\n\r\n    @Autowired\r\n    private AuthenticationService authenticationService;\r\n\r\n    @Override\r\n    public ResponseEntity<AuthResponse> authenticate(AuthRequest authRequest) {\r\n        try {\r\n            AuthResponse response = authenticationService.authenticate(authRequest);\r\n            return ResponseEntity.ok(response);\r\n        } catch (IllegalArgumentException e) {\r\n            log.warning(\"Bad request: \" + e.getMessage());\r\n            return ResponseEntity.badRequest().build();\r\n        } catch (RuntimeException e) {\r\n            log.warning(\"Authentication failed: \" + e.getMessage());\r\n            return ResponseEntity.status(401).build();\r\n        } catch (Exception e) {\r\n            log.severe(\"Error during authentication: \" + e.getMessage());\r\n            return ResponseEntity.status(500).build();\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public ResponseEntity<AuthResponse> signup(SignupRequest signupRequest) {\r\n        try {\r\n            // Validate password match\r\n            if (!signupRequest.getPassword().equals(signupRequest.getConfirmPassword())) {\r\n                Map<String, String> errors = new HashMap<>();\r\n                errors.put(\"password\", \"Password and confirmation password do not match. Please ensure both passwords are identical.\");\r\n                throw new ValidationException(\"signup.password.mismatch\");\r\n            }\r\n\r\n            AuthResponse response = authenticationService.signup(signupRequest);\r\n            return ResponseEntity.status(201).body(response);\r\n        } catch (ValidationException e) {\r\n            log.warning(\"Validation error during signup: \" + e.getMessage());\r\n            return ResponseEntity.badRequest().build();\r\n        } catch (IllegalArgumentException e) {\r\n            log.warning(\"Bad request: \" + e.getMessage());\r\n            return ResponseEntity.badRequest().build();\r\n        } catch (Exception e) {\r\n            log.severe(\"Error during signup: \" + e.getMessage());\r\n            return ResponseEntity.status(500).build();\r\n        }\r\n    }\r\n\r\n\r\n}\r\n\r\n",
              "methods": [
                {
                  "name": "authenticate",
                  "returnType": "Override\r\n    public ResponseEntity<AuthResponse>",
                  "parameters": [
                    "AuthRequest authRequest"
                  ],
                  "annotations": [
                    "@Autowired"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "signup",
                  "returnType": "Override\r\n    public ResponseEntity<AuthResponse>",
                  "parameters": [
                    "SignupRequest signupRequest"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "ValidationException",
                  "returnType": "throw new",
                  "parameters": [
                    "\"signup.password.mismatch\""
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                }
              ],
              "businessRules": [
                "Validate password match\r\n            if (!signupRequest.getPassword().equals(signupRequest.getConfirmPassword())) {\r\n                Map<String, String> errors = new HashMap<>();\r\n                errors.put(\"password\", \"Password and confirmation password do not match. Please ensure both passwords are identical.\");\r\n                throw new ValidationException(\"signup.password.mismatch\");\r\n            }\r\n\r\n            AuthResponse response = authenticationService.signup(signupRequest);\r\n            return ResponseEntity.status(201).body(response);\r\n        } catch (ValidationException e) {\r\n            log.warning(\"Validation error during signup: \" + e.getMessage());\r\n            return ResponseEntity.badRequest().build();\r\n        } catch (IllegalArgumentException e) {\r\n            log.warning(\"Bad request: \" + e.getMessage());\r\n            return ResponseEntity.badRequest().build();\r\n        } catch (Exception e) {\r\n            log.severe(\"Error during signup: \" + e.getMessage());\r\n            return ResponseEntity.status(500).build();\r\n        }\r\n    }\r\n\r\n\r\n}"
              ],
              "relatedClasses": [
                "AuthApi"
              ],
              "dependencies": [
                "Spring Framework"
              ]
            },
            {
              "name": "ChatMessageController",
              "path": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-service-jpa\\src\\main\\java\\org\\sidequest\\parley\\controller\\ChatMessageController.java",
              "type": "class",
              "imports": [
                "org.sidequest.parley.api.ChatsApi",
                "org.sidequest.parley.model.ChatMessage",
                "org.sidequest.parley.model.NewChatMessage",
                "org.sidequest.parley.service.ChatMessageService",
                "org.springframework.beans.factory.annotation.Autowired",
                "org.springframework.context.annotation.Lazy",
                "org.springframework.http.HttpStatus",
                "org.springframework.http.ResponseEntity",
                "org.springframework.web.bind.annotation.RestController",
                "java.util.logging.Logger"
              ],
              "annotations": [
                "@RestController",
                "@Autowired",
                "@Lazy",
                "@Override",
                "@Override"
              ],
              "content": "package org.sidequest.parley.controller;\r\n\r\nimport org.sidequest.parley.api.ChatsApi;\r\nimport org.sidequest.parley.model.ChatMessage;\r\nimport org.sidequest.parley.model.NewChatMessage;\r\nimport org.sidequest.parley.service.ChatMessageService;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.context.annotation.Lazy;\r\nimport org.springframework.http.HttpStatus;\r\nimport org.springframework.http.ResponseEntity;\r\nimport org.springframework.web.bind.annotation.RestController;\r\n\r\nimport java.util.logging.Logger;\r\n\r\n@RestController\r\npublic class ChatMessageController implements ChatsApi {\r\n    private static final Logger log = Logger.getLogger(ChatMessageController.class.getName());\r\n\r\n    ChatMessageService chatMessageService;\r\n\r\n    @Autowired\r\n    public void ChatMessageService(@Lazy ChatMessageService chatMessageService) {\r\n        this.chatMessageService = chatMessageService;\r\n    }\r\n\r\n    @Override\r\n    public ResponseEntity<ChatMessage> getChatMessageById(Long id) {\r\n        try {\r\n            log.info(\"getChatMessageById: \" + id);\r\n\r\n            ChatMessage cm = chatMessageService.getChatMessage(id);\r\n            return ResponseEntity.ok(cm);\r\n        } catch (Exception e) {\r\n            return ResponseEntity.notFound().build();\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public ResponseEntity<ChatMessage> createChatMessage(NewChatMessage newChatMessage) {\r\n        try {\r\n\r\n            ChatMessage chatMessage = chatMessageService.createChatMessage(newChatMessage);\r\n            if (chatMessage == null) {\r\n                return ResponseEntity.notFound().build();\r\n            }\r\n            return new ResponseEntity<>(chatMessage, HttpStatus.CREATED);\r\n        } catch (Exception e) {\r\n            log.severe(\"Error creating chat message:\" + e);\r\n            return ResponseEntity.notFound().build();\r\n        }\r\n    }\r\n}",
              "methods": [
                {
                  "name": "ChatMessageService",
                  "returnType": "Autowired\r\n    public void",
                  "parameters": [
                    "@Lazy ChatMessageService chatMessageService"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "getChatMessageById",
                  "returnType": "Override\r\n    public ResponseEntity<ChatMessage>",
                  "parameters": [
                    "Long id"
                  ],
                  "annotations": [
                    "@Autowired"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "createChatMessage",
                  "returnType": "Override\r\n    public ResponseEntity<ChatMessage>",
                  "parameters": [
                    "NewChatMessage newChatMessage"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "if",
                  "returnType": "",
                  "parameters": [
                    "chatMessage == null"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                }
              ],
              "businessRules": [],
              "relatedClasses": [
                "ChatsApi"
              ],
              "dependencies": [
                "Spring Framework"
              ]
            },
            {
              "name": "ChatRoomController",
              "path": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-service-jpa\\src\\main\\java\\org\\sidequest\\parley\\controller\\ChatRoomController.java",
              "type": "class",
              "imports": [
                "org.sidequest.parley.api.ChatroomsApi",
                "org.sidequest.parley.model.ChatMessage",
                "org.sidequest.parley.model.ChatRoom",
                "org.sidequest.parley.model.Error",
                "org.sidequest.parley.model.NewChatRoom",
                "org.sidequest.parley.service.ChatRoomService",
                "org.springframework.beans.factory.annotation.Autowired",
                "org.springframework.context.annotation.Lazy",
                "org.springframework.core.io.InputStreamResource",
                "org.springframework.core.io.Resource",
                "org.springframework.http.HttpHeaders",
                "org.springframework.http.HttpStatus",
                "org.springframework.http.MediaType",
                "org.springframework.http.ResponseEntity",
                "org.springframework.web.bind.annotation.RestController",
                "org.springframework.web.multipart.MultipartFile",
                "java.io.File",
                "java.io.FileInputStream",
                "java.util.List",
                "java.util.logging.Logger"
              ],
              "annotations": [
                "@RestController",
                "@Autowired",
                "@Lazy",
                "@Override",
                "@Override",
                "@Override",
                "@Override",
                "@Override",
                "@Override",
                "@Override",
                "@Override"
              ],
              "content": "package org.sidequest.parley.controller;\r\n\r\n\r\nimport org.sidequest.parley.api.ChatroomsApi;\r\nimport org.sidequest.parley.model.ChatMessage;\r\nimport org.sidequest.parley.model.ChatRoom;\r\nimport org.sidequest.parley.model.Error;\r\nimport org.sidequest.parley.model.NewChatRoom;\r\nimport org.sidequest.parley.service.ChatRoomService;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.context.annotation.Lazy;\r\nimport org.springframework.core.io.InputStreamResource;\r\nimport org.springframework.core.io.Resource;\r\nimport org.springframework.http.HttpHeaders;\r\nimport org.springframework.http.HttpStatus;\r\nimport org.springframework.http.MediaType;\r\nimport org.springframework.http.ResponseEntity;\r\nimport org.springframework.web.bind.annotation.RestController;\r\nimport org.springframework.web.multipart.MultipartFile;\r\n\r\nimport java.io.File;\r\nimport java.io.FileInputStream;\r\nimport java.util.List;\r\nimport java.util.logging.Logger;\r\n\r\n\r\n/**\r\n * Controller class for managing chat rooms.\r\n */\r\n@RestController\r\npublic class ChatRoomController implements ChatroomsApi {\r\n    private static final Logger log = Logger.getLogger(ChatRoomController.class.getName());\r\n\r\n    private ChatRoomService chatRoomService;\r\n\r\n    @Autowired\r\n    public void setChatRoomService(@Lazy ChatRoomService chatRoomService) {\r\n        this.chatRoomService = chatRoomService;\r\n    }\r\n\r\n    @Override\r\n    public ResponseEntity<List<ChatRoom>> getChatRooms() {\r\n\r\n        try {\r\n\r\n            List<ChatRoom> chatRooms = chatRoomService.getChatRooms();\r\n            for (ChatRoom chatRoom : chatRooms) {\r\n                log.info(\"**** chatRoom: \" + chatRoom.getName());\r\n            }\r\n            return ResponseEntity.ok(chatRooms);\r\n        } catch (Exception e) {\r\n            return ResponseEntity.notFound().build();\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public ResponseEntity<ChatRoom> getChatRoomById(Long id) {\r\n        try {\r\n            ChatRoom chatRoom = chatRoomService.getChatRoom(id);\r\n            return ResponseEntity.ok(chatRoom);\r\n        } catch (Exception e) {\r\n            return ResponseEntity.notFound().build();\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public ResponseEntity<ChatRoom> createChatRoom(NewChatRoom newChatRoom) {\r\n        try {\r\n            ChatRoom chatRoom = chatRoomService.createChatRoom(newChatRoom);\r\n            if (chatRoom != null) {\r\n                return new ResponseEntity<>(chatRoom, HttpStatus.CREATED);\r\n            } else {\r\n                return ResponseEntity.notFound().build();\r\n            }\r\n        } catch (Exception e) {\r\n            log.severe(\"Error creating chat room: \" + e);\r\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public ResponseEntity<ChatRoom> updateChatRoom(Long id, ChatRoom chatRoom) {\r\n        try {\r\n            ChatRoom resultChatRoom = chatRoomService.updateChatRoom(id, chatRoom);\r\n            if (resultChatRoom != null) {\r\n                return new ResponseEntity<>(resultChatRoom, HttpStatus.CREATED);\r\n            } else {\r\n                return ResponseEntity.notFound().build();\r\n            }\r\n        } catch (Exception e) {\r\n            log.severe(\"Error creating chat room: \" + e);\r\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public ResponseEntity<Error> deleteChatRoom(Long id) {\r\n        try {\r\n            chatRoomService.deleteChatRoom(id);\r\n            return ResponseEntity.ok().build();\r\n        } catch (Exception e) {\r\n            return ResponseEntity.notFound().build();\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public ResponseEntity<Void> setChatRoomIcon(Long id, MultipartFile file) {\r\n        try {\r\n            chatRoomService.setChatRoomIcon(id, file);\r\n            return ResponseEntity.ok().build();\r\n        } catch (Exception e) {\r\n            return ResponseEntity.badRequest().build();\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public ResponseEntity<Resource> getChatRoomIcon(Long id) {\r\n        try {\r\n            String avatarPath = chatRoomService.getChatRoomIcon(id);\r\n            File file = new File(avatarPath);\r\n            HttpHeaders headers = new HttpHeaders();\r\n            headers.add(HttpHeaders.CONTENT_DISPOSITION, \"inline;filename=\" + file.getName());\r\n            InputStreamResource resource = new InputStreamResource(new FileInputStream(file));\r\n            return ResponseEntity.ok()\r\n                    .headers(headers)\r\n                    .contentLength(file.length())\r\n                    .contentType(MediaType.IMAGE_PNG) // or MediaType.IMAGE_PNG if it's a PNG image MediaType.IMAGE_JPEG\r\n                    .body(resource);\r\n        } catch (Exception e) {\r\n            return ResponseEntity.badRequest().build();\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public ResponseEntity<List<ChatMessage>> getChatroomChatsByChatRoomId(Long chatRoomId) {\r\n        try {\r\n            List<ChatMessage> chatMessages = chatRoomService.getChatroomChatsByChatRoomId(chatRoomId);\r\n            return ResponseEntity.ok(chatMessages);\r\n        } catch (Exception e) {\r\n            return ResponseEntity.notFound().build();\r\n        }\r\n    }\r\n\r\n}",
              "methods": [
                {
                  "name": "setChatRoomService",
                  "returnType": "Autowired\r\n    public void",
                  "parameters": [
                    "@Lazy ChatRoomService chatRoomService"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "getChatRooms",
                  "returnType": "Override\r\n    public ResponseEntity<List<ChatRoom>>",
                  "parameters": [],
                  "annotations": [
                    "@Autowired"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "for",
                  "returnType": "",
                  "parameters": [
                    "ChatRoom chatRoom : chatRooms"
                  ],
                  "annotations": [
                    "@Override"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "getChatRoomById",
                  "returnType": "Override\r\n    public ResponseEntity<ChatRoom>",
                  "parameters": [
                    "Long id"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "createChatRoom",
                  "returnType": "Override\r\n    public ResponseEntity<ChatRoom>",
                  "parameters": [
                    "NewChatRoom newChatRoom"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "if",
                  "returnType": "",
                  "parameters": [
                    "chatRoom != null"
                  ],
                  "annotations": [
                    "@Override"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "updateChatRoom",
                  "returnType": "Override\r\n    public ResponseEntity<ChatRoom>",
                  "parameters": [
                    "Long id",
                    "ChatRoom chatRoom"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "if",
                  "returnType": "",
                  "parameters": [
                    "resultChatRoom != null"
                  ],
                  "annotations": [
                    "@Override"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "deleteChatRoom",
                  "returnType": "Override\r\n    public ResponseEntity<Error>",
                  "parameters": [
                    "Long id"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "setChatRoomIcon",
                  "returnType": "Override\r\n    public ResponseEntity<Void>",
                  "parameters": [
                    "Long id",
                    "MultipartFile file"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "getChatRoomIcon",
                  "returnType": "Override\r\n    public ResponseEntity<Resource>",
                  "parameters": [
                    "Long id"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "File",
                  "returnType": "new",
                  "parameters": [
                    "avatarPath"
                  ],
                  "annotations": [
                    "@Override"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "HttpHeaders",
                  "returnType": "new",
                  "parameters": [],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "getChatroomChatsByChatRoomId",
                  "returnType": "Override\r\n    public ResponseEntity<List<ChatMessage>>",
                  "parameters": [
                    "Long chatRoomId"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                }
              ],
              "businessRules": [],
              "relatedClasses": [
                "ChatroomsApi"
              ],
              "dependencies": [
                "Spring Framework"
              ]
            },
            {
              "name": "EnrollmentController",
              "path": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-service-jpa\\src\\main\\java\\org\\sidequest\\parley\\controller\\EnrollmentController.java",
              "type": "class",
              "imports": [
                "org.sidequest.parley.api.EnrollmentsApi",
                "org.sidequest.parley.model.Enrollment",
                "org.sidequest.parley.model.NewEnrollment",
                "org.sidequest.parley.service.EnrollmentService",
                "org.springframework.beans.factory.annotation.Autowired",
                "org.springframework.http.HttpStatus",
                "org.springframework.http.ResponseEntity",
                "org.springframework.web.bind.annotation.RestController",
                "java.util.List",
                "java.util.logging.Logger"
              ],
              "annotations": [
                "@RestController",
                "@Autowired",
                "@Override",
                "@Override",
                "@Override",
                "@Override",
                "@Override"
              ],
              "content": "package org.sidequest.parley.controller;\r\n\r\nimport org.sidequest.parley.api.EnrollmentsApi;\r\nimport org.sidequest.parley.model.Enrollment;\r\nimport org.sidequest.parley.model.NewEnrollment;\r\nimport org.sidequest.parley.service.EnrollmentService;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.http.HttpStatus;\r\nimport org.springframework.http.ResponseEntity;\r\nimport org.springframework.web.bind.annotation.RestController;\r\n\r\nimport java.util.List;\r\nimport java.util.logging.Logger;\r\n\r\n@RestController\r\npublic class EnrollmentController implements EnrollmentsApi {\r\n\r\n    private static final Logger log = Logger.getLogger(EnrollmentController.class.getName());\r\n\r\n    @Autowired\r\n    private EnrollmentService enrollmentService;\r\n\r\n    @Override\r\n    public ResponseEntity<List<Enrollment>> addUsersToChatRooms(List<NewEnrollment> enrollment) {\r\n        try {\r\n            List<Enrollment> enrollments = enrollmentService.addUsersToChatRoom(enrollment);\r\n            return ResponseEntity.status(HttpStatus.CREATED).body(enrollments);\r\n        } catch (Exception e) {\r\n            log.severe(\"Error adding users to chat rooms: \" + e.getMessage());\r\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public ResponseEntity<Void> addUserToChatRoom(Long chatRoomId, Long userId) {\r\n        try {\r\n            Enrollment newEnrollment = enrollmentService.addUserToChatRoom(chatRoomId, userId);\r\n            return ResponseEntity.status(HttpStatus.CREATED).build();\r\n        } catch (Exception e) {\r\n            log.severe(\"Error adding user to chat room: \" + e.getMessage());\r\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public ResponseEntity<List<Enrollment>> getEnrollmentsByChatRoomId(Long chatRoomId) {\r\n        try {\r\n            List<Enrollment> enrollments = enrollmentService.getEnrollmentsByChatRoomId(chatRoomId);\r\n            return ResponseEntity.status(HttpStatus.CREATED).body(enrollments);\r\n        } catch (Exception e) {\r\n            log.severe(\"Error getting enrollments by chat room id: \" + e.getMessage());\r\n            return ResponseEntity.notFound().build();\r\n        }\r\n    }\r\n\r\n\r\n    @Override\r\n    public ResponseEntity<Void> removeUserFromChatRoom(Long chatRoomId, Long userId) {\r\n        try {\r\n            enrollmentService.removeUserFromChatRoom(chatRoomId, userId);\r\n            return ResponseEntity.ok().build();\r\n        } catch (Exception e) {\r\n            log.severe(\"Error removing user from chat room: \" + e.getMessage());\r\n            return ResponseEntity.notFound().build();\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public ResponseEntity<Void> removeUsersFromChatRoom(Long chatRoomId) {\r\n        try {\r\n            enrollmentService.removeUsersFromChatRoom(chatRoomId);\r\n            return ResponseEntity.ok().build();\r\n        } catch (Exception e) {\r\n            log.severe(\"Error removing users from chat room: \" + e.getMessage());\r\n            return ResponseEntity.notFound().build();\r\n        }\r\n    }\r\n}\r\n",
              "methods": [
                {
                  "name": "addUsersToChatRooms",
                  "returnType": "Override\r\n    public ResponseEntity<List<Enrollment>>",
                  "parameters": [
                    "List<NewEnrollment> enrollment"
                  ],
                  "annotations": [
                    "@Autowired"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "addUserToChatRoom",
                  "returnType": "Override\r\n    public ResponseEntity<Void>",
                  "parameters": [
                    "Long chatRoomId",
                    "Long userId"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "getEnrollmentsByChatRoomId",
                  "returnType": "Override\r\n    public ResponseEntity<List<Enrollment>>",
                  "parameters": [
                    "Long chatRoomId"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "removeUserFromChatRoom",
                  "returnType": "Override\r\n    public ResponseEntity<Void>",
                  "parameters": [
                    "Long chatRoomId",
                    "Long userId"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "removeUsersFromChatRoom",
                  "returnType": "Override\r\n    public ResponseEntity<Void>",
                  "parameters": [
                    "Long chatRoomId"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                }
              ],
              "businessRules": [],
              "relatedClasses": [
                "EnrollmentsApi"
              ],
              "dependencies": [
                "Spring Framework"
              ]
            },
            {
              "name": "StreamsController",
              "path": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-service-jpa\\src\\main\\java\\org\\sidequest\\parley\\controller\\StreamsController.java",
              "type": "class",
              "imports": [
                "org.sidequest.parley.api.StreamsApi",
                "org.springframework.http.HttpStatus",
                "org.springframework.http.ResponseEntity",
                "org.springframework.web.bind.annotation.RestController",
                "org.springframework.web.servlet.mvc.method.annotation.SseEmitter",
                "java.io.IOException",
                "java.net.URI"
              ],
              "annotations": [
                "@RestController",
                "@Override"
              ],
              "content": "//package org.sidequest.parley.controller;\r\n//\r\n//\r\n//import org.sidequest.parley.api.StreamsApi;\r\n//import org.springframework.http.HttpStatus;\r\n//import org.springframework.http.ResponseEntity;\r\n//import org.springframework.web.bind.annotation.RestController;\r\n//import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;\r\n//\r\n//import java.io.IOException;\r\n//import java.net.URI;\r\n//\r\n//@RestController\r\n//public class StreamsController implements StreamsApi {\r\n//\r\n//    @Override\r\n//    public ResponseEntity<Object> createStream(URI callbackUrl) {\r\n//        SseEmitter emitter = new SseEmitter();\r\n//        try {\r\n//            emitter.send(\"Hello World!\");\r\n//\r\n//        } catch (IOException e) {\r\n//            e.printStackTrace();\r\n//        }\r\n//        return new ResponseEntity<>(emitter, HttpStatus.CREATED);\r\n//\r\n//    }\r\n//}\r\n",
              "methods": [
                {
                  "name": "createStream",
                  "returnType": "public ResponseEntity<Object>",
                  "parameters": [
                    "URI callbackUrl"
                  ],
                  "annotations": [
                    "@RestController",
                    "@Override"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "SseEmitter",
                  "returnType": "new",
                  "parameters": [],
                  "annotations": [
                    "@RestController",
                    "@Override"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                }
              ],
              "businessRules": [],
              "relatedClasses": [
                "StreamsApi"
              ],
              "dependencies": []
            },
            {
              "name": "UserController",
              "path": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-service-jpa\\src\\main\\java\\org\\sidequest\\parley\\controller\\UserController.java",
              "type": "class",
              "imports": [
                "org.sidequest.parley.api.UsersApi",
                "org.sidequest.parley.model.ChatRoom",
                "org.sidequest.parley.model.NewUser",
                "org.sidequest.parley.model.User",
                "org.sidequest.parley.service.UserService",
                "org.springframework.beans.factory.annotation.Autowired",
                "org.springframework.core.io.InputStreamResource",
                "org.springframework.core.io.Resource",
                "org.springframework.http.HttpHeaders",
                "org.springframework.http.HttpStatus",
                "org.springframework.http.MediaType",
                "org.springframework.http.ResponseEntity",
                "org.springframework.web.bind.annotation.RestController",
                "org.springframework.web.multipart.MultipartFile",
                "java.io.File",
                "java.io.FileInputStream",
                "java.util.List",
                "java.util.logging.Logger"
              ],
              "annotations": [
                "@Service",
                "@RestController",
                "@Autowired",
                "@return",
                "@Override",
                "@Override",
                "@Override",
                "@Override",
                "@Override",
                "@Override",
                "@Override"
              ],
              "content": "package org.sidequest.parley.controller;\r\n\r\nimport org.sidequest.parley.api.UsersApi;\r\nimport org.sidequest.parley.model.ChatRoom;\r\nimport org.sidequest.parley.model.NewUser;\r\nimport org.sidequest.parley.model.User;\r\nimport org.sidequest.parley.service.UserService;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.core.io.InputStreamResource;\r\nimport org.springframework.core.io.Resource;\r\nimport org.springframework.http.HttpHeaders;\r\nimport org.springframework.http.HttpStatus;\r\nimport org.springframework.http.MediaType;\r\nimport org.springframework.http.ResponseEntity;\r\nimport org.springframework.web.bind.annotation.RestController;\r\nimport org.springframework.web.multipart.MultipartFile;\r\n\r\nimport java.io.File;\r\nimport java.io.FileInputStream;\r\nimport java.util.List;\r\nimport java.util.logging.Logger;\r\n\r\n/**\r\n * A RESTful web service controller for managing users.\r\n */\r\n//@Service\r\n@RestController\r\npublic class UserController implements UsersApi {\r\n    private static final Logger log = Logger.getLogger(UserController.class.getName());\r\n\r\n    @Autowired\r\n    UserService userService;\r\n\r\n    /**\r\n     * Retrieves a list of all users in JSON format.\r\n     *\r\n     * @return A JSON-formatted string containing an array of users.\r\n     */\r\n    @Override\r\n//    public ResponseEntity<List<org.sidequest.parley.model.User>> getUsers() {\r\n    public ResponseEntity<List<User>> getUsers() {\r\n        try {\r\n            List<User> users = userService.getUsers();\r\n            return ResponseEntity.ok(users);\r\n        } catch (Exception e) {\r\n            return ResponseEntity.notFound().build();\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public ResponseEntity<User> getUserById(Long id) {\r\n        try {\r\n            User user = userService.getUser(id);\r\n            return ResponseEntity.ok(user);\r\n        } catch (Exception e) {\r\n            return ResponseEntity.notFound().build();\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public ResponseEntity<User> createUser(NewUser newUser) {\r\n        try {\r\n            log.fine(\"createUser: \" + newUser.getName() + \" \" + newUser.getTimezone());\r\n            User user = userService.createUser(newUser.getName(), newUser.getTimezone());\r\n            if (user == null) {\r\n                return ResponseEntity.notFound().build();\r\n            }\r\n            return new ResponseEntity<>(user, HttpStatus.CREATED);\r\n        } catch (IllegalArgumentException e) {\r\n            log.severe(\"Error creating user:\" + e);\r\n            return ResponseEntity.badRequest().build();\r\n        } catch (Exception e) {\r\n            log.severe(\"Error creating user:\" + e);\r\n            return ResponseEntity.notFound().build();\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public ResponseEntity<Void> setUserAvatar(Long id, MultipartFile file) {\r\n        try {\r\n            userService.setUserAvatar(id, file);\r\n            return ResponseEntity.ok().build();\r\n        } catch (Exception e) {\r\n            return ResponseEntity.badRequest().build();\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public ResponseEntity<Resource> getUserAvatar(Long id) {\r\n        try {\r\n            String avatarPath = userService.getUserAvatar(id);\r\n            File file = new File(avatarPath);\r\n            HttpHeaders headers = new HttpHeaders();\r\n            headers.add(HttpHeaders.CONTENT_DISPOSITION, \"inline;filename=\" + file.getName());\r\n            InputStreamResource resource = new InputStreamResource(new FileInputStream(file));\r\n            return ResponseEntity.ok()\r\n                    .headers(headers)\r\n                    .contentLength(file.length())\r\n                    .contentType(MediaType.IMAGE_PNG) // or MediaType.IMAGE_PNG if it's a PNG image MediaType.IMAGE_JPEG\r\n                    .body(resource);\r\n        } catch (Exception e) {\r\n            return ResponseEntity.badRequest().build();\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public ResponseEntity<List<ChatRoom>> getChatRoomsByUserId(Long userId) {\r\n        try {\r\n            List<ChatRoom> chatRooms = userService.getChatRoomsByUserId(userId);\r\n            return ResponseEntity.ok(chatRooms);\r\n        } catch (Exception e) {\r\n            log.severe(\"Error getting chat rooms for user: \" + e.getMessage());\r\n            return ResponseEntity.notFound().build();\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public ResponseEntity<User> updateUserById(Long id, NewUser newUser) {\r\n        try {\r\n            User user = userService.updateUserById(id, newUser);\r\n            //return ResponseEntity.ok().build();\r\n            return new ResponseEntity<>(user, HttpStatus.CREATED);\r\n        } catch (Exception e) {\r\n            return ResponseEntity.badRequest().build();\r\n        }\r\n    }\r\n}",
              "methods": [
                {
                  "name": "getUsers",
                  "returnType": "public ResponseEntity<List<org.sidequest.parley.model.User>>",
                  "parameters": [],
                  "annotations": [
                    "@Override"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "getUsers",
                  "returnType": "public ResponseEntity<List<User>>",
                  "parameters": [],
                  "annotations": [
                    "@Override"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "getUserById",
                  "returnType": "Override\r\n    public ResponseEntity<User>",
                  "parameters": [
                    "Long id"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "createUser",
                  "returnType": "Override\r\n    public ResponseEntity<User>",
                  "parameters": [
                    "NewUser newUser"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "if",
                  "returnType": "",
                  "parameters": [
                    "user == null"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "setUserAvatar",
                  "returnType": "Override\r\n    public ResponseEntity<Void>",
                  "parameters": [
                    "Long id",
                    "MultipartFile file"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "getUserAvatar",
                  "returnType": "Override\r\n    public ResponseEntity<Resource>",
                  "parameters": [
                    "Long id"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "File",
                  "returnType": "new",
                  "parameters": [
                    "avatarPath"
                  ],
                  "annotations": [
                    "@Override"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "HttpHeaders",
                  "returnType": "new",
                  "parameters": [],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "getChatRoomsByUserId",
                  "returnType": "Override\r\n    public ResponseEntity<List<ChatRoom>>",
                  "parameters": [
                    "Long userId"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "updateUserById",
                  "returnType": "Override\r\n    public ResponseEntity<User>",
                  "parameters": [
                    "Long id",
                    "NewUser newUser"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                }
              ],
              "businessRules": [],
              "relatedClasses": [
                "UsersApi"
              ],
              "dependencies": [
                "Spring Framework"
              ]
            }
          ]
        },
        {
          "name": "org.sidequest.parley.util",
          "classes": [
            {
              "name": "EmailHelper",
              "path": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-service-jpa\\src\\main\\java\\org\\sidequest\\parley\\util\\EmailHelper.java",
              "type": "class",
              "imports": [
                "org.springframework.beans.factory.annotation.Value",
                "org.springframework.stereotype.Component",
                "javax.mail.*",
                "javax.mail.internet.InternetAddress",
                "javax.mail.internet.MimeMessage",
                "java.util.Properties"
              ],
              "annotations": [
                "@Component",
                "@Value(\"${spring.mail.host}\")",
                "@Value(\"${spring.mail.port}\")",
                "@Value(\"${spring.mail.username}\")",
                "@Value(\"${spring.mail.password}\")",
                "@Value(\"${spring.mail.from}\")"
              ],
              "content": "package org.sidequest.parley.util;\r\n\r\nimport org.springframework.beans.factory.annotation.Value;\r\nimport org.springframework.stereotype.Component;\r\n\r\nimport javax.mail.*;\r\nimport javax.mail.internet.InternetAddress;\r\nimport javax.mail.internet.MimeMessage;\r\nimport java.util.Properties;\r\n\r\n@Component\r\npublic class EmailHelper {\r\n\r\n    @Value(\"${spring.mail.host}\")\r\n    private String smtpHost;\r\n\r\n    @Value(\"${spring.mail.port}\")\r\n    private int smtpPort;\r\n\r\n    @Value(\"${spring.mail.username}\")\r\n    private String smtpUsername;\r\n\r\n    @Value(\"${spring.mail.password}\")\r\n    private String smtpPassword;\r\n\r\n    @Value(\"${spring.mail.from}\")\r\n    private String fromEmail;\r\n\r\n    public void sendPasswordResetEmail(String email, String resetToken) {\r\n        Properties props = new Properties();\r\n        props.put(\"mail.smtp.auth\", \"true\");\r\n        props.put(\"mail.smtp.starttls.enable\", \"true\");\r\n        props.put(\"mail.smtp.host\", smtpHost);\r\n        props.put(\"mail.smtp.port\", String.valueOf(smtpPort));\r\n\r\n        Session session = Session.getInstance(props, new Authenticator() {\r\n            protected PasswordAuthentication getPasswordAuthentication() {\r\n                return new PasswordAuthentication(smtpUsername, smtpPassword);\r\n            }\r\n        });\r\n\r\n        try {\r\n            Message message = new MimeMessage(session);\r\n            message.setFrom(new InternetAddress(fromEmail));\r\n            message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(email));\r\n            message.setSubject(\"Password Reset Request\");\r\n\r\n            String resetLink = \"http://localhost:8080/parley/reset-password?token=\" + resetToken;\r\n            StringBuilder emailContent = new StringBuilder();\r\n            emailContent.append(\"Hello,\\n\\n\");\r\n            emailContent.append(\"A password reset was requested for your Parley account.\\n\\n\");\r\n            emailContent.append(\"Click the following link to reset your password:\\n\");\r\n            emailContent.append(resetLink).append(\"\\n\\n\");\r\n            emailContent.append(\"This link will expire in 24 hours.\\n\\n\");\r\n            emailContent.append(\"If you did not request this password reset, please ignore this email.\\n\\n\");\r\n            emailContent.append(\"Best regards,\\nThe Parley Team\");\r\n\r\n            message.setText(emailContent.toString());\r\n\r\n            Transport.send(message);\r\n        } catch (MessagingException e) {\r\n            throw new RuntimeException(\"Failed to send password reset email\", e);\r\n        }\r\n    }\r\n}",
              "methods": [
                {
                  "name": "sendPasswordResetEmail",
                  "returnType": "public void",
                  "parameters": [
                    "String email",
                    "String resetToken"
                  ],
                  "annotations": [
                    "@Value(\"${spring.mail.password}\")",
                    "@Value(\"${spring.mail.from}\")"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "Properties",
                  "returnType": "new",
                  "parameters": [],
                  "annotations": [
                    "@Value(\"${spring.mail.from}\")"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "Authenticator",
                  "returnType": "new",
                  "parameters": [],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "getPasswordAuthentication",
                  "returnType": "protected PasswordAuthentication",
                  "parameters": [],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "PasswordAuthentication",
                  "returnType": "return new",
                  "parameters": [
                    "smtpUsername",
                    "smtpPassword"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "MimeMessage",
                  "returnType": "new",
                  "parameters": [
                    "session"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "StringBuilder",
                  "returnType": "new",
                  "parameters": [],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "RuntimeException",
                  "returnType": "throw new",
                  "parameters": [
                    "\"Failed to send password reset email\"",
                    "e"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                }
              ],
              "businessRules": [],
              "relatedClasses": [],
              "dependencies": [
                "Spring Framework"
              ]
            },
            {
              "name": "FileSystemHelper",
              "path": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-service-jpa\\src\\main\\java\\org\\sidequest\\parley\\util\\FileSystemHelper.java",
              "type": "class",
              "imports": [
                "org.springframework.stereotype.Component",
                "org.springframework.web.multipart.MultipartFile",
                "java.io.File",
                "java.io.IOException",
                "java.nio.file.Files",
                "java.nio.file.Path",
                "java.nio.file.Paths",
                "java.util.ArrayList",
                "java.util.List",
                "java.util.logging.Level",
                "java.util.logging.Logger"
              ],
              "annotations": [
                "@Component"
              ],
              "content": "package org.sidequest.parley.util;\r\n\r\nimport org.springframework.stereotype.Component;\r\nimport org.springframework.web.multipart.MultipartFile;\r\n\r\nimport java.io.File;\r\nimport java.io.IOException;\r\nimport java.nio.file.Files;\r\nimport java.nio.file.Path;\r\nimport java.nio.file.Paths;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\n\r\n@Component\r\npublic class FileSystemHelper {\r\n\r\n    private static final Logger logger = Logger.getLogger(FileSystemHelper.class.getName());\r\n\r\n    // Save a file to a specified directory and return the path of the saved file\r\n    public String saveFile(MultipartFile file, String directoryPath) {\r\n        if (file == null || directoryPath == null) {\r\n            logger.warning(\"File or directoryPath is null.\");\r\n            throw new IllegalArgumentException(\"File and directoryPath cannot be null.\");\r\n        }\r\n\r\n        try {\r\n            File directory = new File(directoryPath);\r\n            if (!directory.exists()) {\r\n                boolean dirsCreated = directory.mkdirs();\r\n                if (!dirsCreated) {\r\n                    logger.warning(\"Failed to create directories: \" + directoryPath);\r\n                    throw new IOException(\"Failed to create directories: \" + directoryPath);\r\n                }\r\n            }\r\n\r\n            File destinationFile = new File(directory, file.getOriginalFilename());\r\n            file.transferTo(destinationFile);\r\n            logger.info(\"File saved successfully: \" + destinationFile.getAbsolutePath());\r\n            return destinationFile.getAbsolutePath();\r\n        } catch (IOException e) {\r\n            logger.log(Level.SEVERE, \"Failed to save file: \" + file.getOriginalFilename(), e);\r\n            throw new RuntimeException(\"Failed to save file: \" + file.getOriginalFilename(), e);\r\n        }\r\n    }\r\n\r\n    // Delete a file\r\n    public boolean deleteFile(String filePath) {\r\n        if (filePath == null) {\r\n            logger.warning(\"filePath is null.\");\r\n            throw new IllegalArgumentException(\"filePath cannot be null.\");\r\n        }\r\n\r\n        try {\r\n            File file = new File(filePath);\r\n            if (file.exists() && file.delete()) {\r\n                logger.info(\"File deleted successfully: \" + filePath);\r\n                return true;\r\n            } else {\r\n                logger.warning(\"File not found or could not be deleted: \" + filePath);\r\n                return false;\r\n            }\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Failed to delete file: \" + filePath, e);\r\n            throw new RuntimeException(\"Failed to delete file: \" + filePath, e);\r\n        }\r\n    }\r\n\r\n    // List all files in a directory\r\n    public List<String> listFiles(String directoryPath) {\r\n        if (directoryPath == null) {\r\n            logger.warning(\"directoryPath is null.\");\r\n            throw new IllegalArgumentException(\"directoryPath cannot be null.\");\r\n        }\r\n\r\n        List<String> fileList = new ArrayList<>();\r\n        try {\r\n            File directory = new File(directoryPath);\r\n            if (directory.exists() && directory.isDirectory()) {\r\n                File[] files = directory.listFiles();\r\n                if (files != null) {\r\n                    for (File file : files) {\r\n                        fileList.add(file.getAbsolutePath());\r\n                    }\r\n                }\r\n                logger.info(\"Listed files in directory: \" + directoryPath);\r\n            } else {\r\n                logger.warning(\"Directory not found or is not a directory: \" + directoryPath);\r\n            }\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Failed to list files in directory: \" + directoryPath, e);\r\n            throw new RuntimeException(\"Failed to list files in directory: \" + directoryPath, e);\r\n        }\r\n        return fileList;\r\n    }\r\n\r\n    // Check if a file or directory exists\r\n    public boolean exists(String path) {\r\n        if (path == null) {\r\n            logger.warning(\"path is null.\");\r\n            throw new IllegalArgumentException(\"path cannot be null.\");\r\n        }\r\n\r\n        try {\r\n            File file = new File(path);\r\n            boolean exists = file.exists();\r\n            logger.info(\"File or directory \" + (exists ? \"exists\" : \"does not exist\") + \": \" + path);\r\n            return exists;\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Failed to check existence of path: \" + path, e);\r\n            throw new RuntimeException(\"Failed to check existence of path: \" + path, e);\r\n        }\r\n    }\r\n\r\n    // Create a directory\r\n    public boolean createDirectory(String directoryPath) {\r\n        if (directoryPath == null) {\r\n            logger.warning(\"directoryPath is null.\");\r\n            throw new IllegalArgumentException(\"directoryPath cannot be null.\");\r\n        }\r\n\r\n        try {\r\n            File directory = new File(directoryPath);\r\n            if (!directory.exists()) {\r\n                boolean created = directory.mkdirs();\r\n                logger.info(\"Directory \" + (created ? \"created\" : \"not created\") + \": \" + directoryPath);\r\n                return created;\r\n            } else {\r\n                logger.warning(\"Directory already exists: \" + directoryPath);\r\n                return false;\r\n            }\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Failed to create directory: \" + directoryPath, e);\r\n            throw new RuntimeException(\"Failed to create directory: \" + directoryPath, e);\r\n        }\r\n    }\r\n\r\n    // Read the content of a file as a string\r\n    public String readFileContent(String filePath) {\r\n        if (filePath == null) {\r\n            logger.warning(\"filePath is null.\");\r\n            throw new IllegalArgumentException(\"filePath cannot be null.\");\r\n        }\r\n\r\n        try {\r\n            Path path = Paths.get(filePath);\r\n            String content = Files.readString(path);\r\n            logger.info(\"Read file content: \" + filePath);\r\n            return content;\r\n        } catch (IOException e) {\r\n            logger.log(Level.SEVERE, \"Failed to read file content: \" + filePath, e);\r\n            throw new RuntimeException(\"Failed to read file content: \" + filePath, e);\r\n        }\r\n    }\r\n\r\n    // Write content to a file\r\n    public void writeFileContent(String filePath, String content) {\r\n        if (filePath == null || content == null) {\r\n            logger.warning(\"filePath or content is null.\");\r\n            throw new IllegalArgumentException(\"filePath and content cannot be null.\");\r\n        }\r\n\r\n        try {\r\n            Path path = Paths.get(filePath);\r\n            Files.writeString(path, content);\r\n            logger.info(\"Wrote content to file: \" + filePath);\r\n        } catch (IOException e) {\r\n            logger.log(Level.SEVERE, \"Failed to write file content: \" + filePath, e);\r\n            throw new RuntimeException(\"Failed to write file content: \" + filePath, e);\r\n        }\r\n    }\r\n}\r\n",
              "methods": [
                {
                  "name": "saveFile",
                  "returnType": "Save a file to a specified directory and return the path of the saved file\r\n    public String",
                  "parameters": [
                    "MultipartFile file",
                    "String directoryPath"
                  ],
                  "annotations": [
                    "@Component"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "if",
                  "returnType": "",
                  "parameters": [
                    "file == null || directoryPath == null"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "IllegalArgumentException",
                  "returnType": "throw new",
                  "parameters": [
                    "\"File and directoryPath cannot be null.\""
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "File",
                  "returnType": "new",
                  "parameters": [
                    "directoryPath"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "if",
                  "returnType": "",
                  "parameters": [
                    "!dirsCreated"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "IOException",
                  "returnType": "throw new",
                  "parameters": [
                    "\"Failed to create directories: \" + directoryPath"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "deleteFile",
                  "returnType": "Delete a file\r\n    public boolean",
                  "parameters": [
                    "String filePath"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "if",
                  "returnType": "",
                  "parameters": [
                    "filePath == null"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "IllegalArgumentException",
                  "returnType": "throw new",
                  "parameters": [
                    "\"filePath cannot be null.\""
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "File",
                  "returnType": "new",
                  "parameters": [
                    "filePath"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "RuntimeException",
                  "returnType": "throw new",
                  "parameters": [
                    "\"Failed to delete file: \" + filePath",
                    "e"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "listFiles",
                  "returnType": "List all files in a directory\r\n    public List<String>",
                  "parameters": [
                    "String directoryPath"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "if",
                  "returnType": "",
                  "parameters": [
                    "directoryPath == null"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "IllegalArgumentException",
                  "returnType": "throw new",
                  "parameters": [
                    "\"directoryPath cannot be null.\""
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "File",
                  "returnType": "new",
                  "parameters": [
                    "directoryPath"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "if",
                  "returnType": "",
                  "parameters": [
                    "files != null"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "for",
                  "returnType": "",
                  "parameters": [
                    "File file : files"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "RuntimeException",
                  "returnType": "throw new",
                  "parameters": [
                    "\"Failed to list files in directory: \" + directoryPath",
                    "e"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "exists",
                  "returnType": "Check if a file or directory exists\r\n    public boolean",
                  "parameters": [
                    "String path"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "if",
                  "returnType": "",
                  "parameters": [
                    "path == null"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "IllegalArgumentException",
                  "returnType": "throw new",
                  "parameters": [
                    "\"path cannot be null.\""
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "File",
                  "returnType": "new",
                  "parameters": [
                    "path"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "RuntimeException",
                  "returnType": "throw new",
                  "parameters": [
                    "\"Failed to check existence of path: \" + path",
                    "e"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "createDirectory",
                  "returnType": "Create a directory\r\n    public boolean",
                  "parameters": [
                    "String directoryPath"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "if",
                  "returnType": "",
                  "parameters": [
                    "directoryPath == null"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "IllegalArgumentException",
                  "returnType": "throw new",
                  "parameters": [
                    "\"directoryPath cannot be null.\""
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "File",
                  "returnType": "new",
                  "parameters": [
                    "directoryPath"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "RuntimeException",
                  "returnType": "throw new",
                  "parameters": [
                    "\"Failed to create directory: \" + directoryPath",
                    "e"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "readFileContent",
                  "returnType": "Read the content of a file as a string\r\n    public String",
                  "parameters": [
                    "String filePath"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "if",
                  "returnType": "",
                  "parameters": [
                    "filePath == null"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "IllegalArgumentException",
                  "returnType": "throw new",
                  "parameters": [
                    "\"filePath cannot be null.\""
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "RuntimeException",
                  "returnType": "throw new",
                  "parameters": [
                    "\"Failed to read file content: \" + filePath",
                    "e"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "writeFileContent",
                  "returnType": "Write content to a file\r\n    public void",
                  "parameters": [
                    "String filePath",
                    "String content"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "if",
                  "returnType": "",
                  "parameters": [
                    "filePath == null || content == null"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "IllegalArgumentException",
                  "returnType": "throw new",
                  "parameters": [
                    "\"filePath and content cannot be null.\""
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "RuntimeException",
                  "returnType": "throw new",
                  "parameters": [
                    "\"Failed to write file content: \" + filePath",
                    "e"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                }
              ],
              "businessRules": [],
              "relatedClasses": [],
              "dependencies": [
                "Spring Framework"
              ]
            },
            {
              "name": "TimeHelper",
              "path": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-service-jpa\\src\\main\\java\\org\\sidequest\\parley\\util\\TimeHelper.java",
              "type": "class",
              "imports": [
                "org.springframework.beans.factory.annotation.Value",
                "org.springframework.stereotype.Component",
                "java.time.OffsetDateTime",
                "java.time.ZoneId",
                "java.time.ZoneOffset",
                "java.time.zone.ZoneRulesException",
                "java.util.logging.Logger"
              ],
              "annotations": [
                "@Component",
                "@Value(\"${default.timezone}\")",
                "@param",
                "@return",
                "@param",
                "@param",
                "@return"
              ],
              "content": "package org.sidequest.parley.util;\r\n\r\nimport org.springframework.beans.factory.annotation.Value;\r\nimport org.springframework.stereotype.Component;\r\n\r\nimport java.time.OffsetDateTime;\r\nimport java.time.ZoneId;\r\nimport java.time.ZoneOffset;\r\nimport java.time.zone.ZoneRulesException;\r\nimport java.util.logging.Logger;\r\n\r\n/**\r\n * A utility class that provides helper methods for managing time-related operations.\r\n */\r\n@Component\r\npublic class TimeHelper {\r\n    private static final Logger log = Logger.getLogger(TimeHelper.class.getName());\r\n\r\n    @Value(\"${default.timezone}\")\r\n    private String defaultTimezone;\r\n\r\n    public ZoneId getZoneId(String timezone) {\r\n        try {\r\n            return timezone != null ? ZoneId.of(timezone) : null;\r\n        } catch (Exception e) {\r\n            log.warning(\"Invalid timezone: \" + timezone + \". Using default: \" + defaultTimezone);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public ZoneId getDefaultZoneId() {\r\n        return ZoneId.of(defaultTimezone);\r\n    }\r\n\r\n    public boolean isTimezone(String timezone) {\r\n        try {\r\n            ZoneId.of(timezone);\r\n            return true;\r\n        } catch (ZoneRulesException e) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Converts a ZonedDateTime to UTC.\r\n     *\r\n     * @param localDateTime the OffsetDateTime to be converted to UTC\r\n     * @return the OffsetDateTime in UTC\r\n     */\r\n    public static OffsetDateTime toUtc(OffsetDateTime localDateTime) {\r\n        try {\r\n            if (localDateTime == null) {\r\n                return null;\r\n            }\r\n            return localDateTime.withOffsetSameInstant(ZoneOffset.UTC);\r\n        } catch (Exception e) {\r\n            log.severe(\"Error converting to UTC: \" + e);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Converts an OffsetDateTime to the local time of the specified ZoneId.\r\n     *\r\n     * @param odt     the OffsetDateTime to be converted\r\n     * @param zoneId the ZoneId to convert to\r\n     * @return the OffsetDateTime in the local time of the specified ZoneId\r\n     */\r\n    public static OffsetDateTime fromUtc(OffsetDateTime odt, ZoneId zoneId) {\r\n        try {\r\n            if (odt == null || zoneId == null) {\r\n                return null;\r\n            }\r\n            return odt.atZoneSameInstant(zoneId).toOffsetDateTime();\r\n        } catch (Exception e) {\r\n            log.severe(\"Error converting from UTC: \" + e);\r\n            return null;\r\n        }\r\n    }\r\n\r\n}",
              "methods": [
                {
                  "name": "getZoneId",
                  "returnType": "public ZoneId",
                  "parameters": [
                    "String timezone"
                  ],
                  "annotations": [
                    "@Component",
                    "@Value(\"${default.timezone}\")"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "getDefaultZoneId",
                  "returnType": "public ZoneId",
                  "parameters": [],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "isTimezone",
                  "returnType": "public boolean",
                  "parameters": [
                    "String timezone"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "toUtc",
                  "returnType": "public static OffsetDateTime",
                  "parameters": [
                    "OffsetDateTime localDateTime"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "if",
                  "returnType": "",
                  "parameters": [
                    "localDateTime == null"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "fromUtc",
                  "returnType": "public static OffsetDateTime",
                  "parameters": [
                    "OffsetDateTime odt",
                    "ZoneId zoneId"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "if",
                  "returnType": "",
                  "parameters": [
                    "odt == null || zoneId == null"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                }
              ],
              "businessRules": [],
              "relatedClasses": [],
              "dependencies": [
                "Spring Framework"
              ]
            }
          ]
        },
        {
          "name": "org.sidequest.parley",
          "classes": [
            {
              "name": "ParleyApplication",
              "path": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-service-jpa\\src\\main\\java\\org\\sidequest\\parley\\ParleyApplication.java",
              "type": "class",
              "imports": [
                "org.springframework.boot.CommandLineRunner",
                "org.springframework.boot.SpringApplication",
                "org.springframework.boot.autoconfigure.SpringBootApplication",
                "org.springframework.boot.web.servlet.support.SpringBootServletInitializer",
                "org.springframework.context.annotation.Bean",
                "java.util.logging.Logger"
              ],
              "annotations": [
                "@SpringBootApplication",
                "@Bean"
              ],
              "content": "package org.sidequest.parley;\r\n\r\n\r\nimport org.springframework.boot.CommandLineRunner;\r\nimport org.springframework.boot.SpringApplication;\r\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\r\nimport org.springframework.boot.web.servlet.support.SpringBootServletInitializer;\r\nimport org.springframework.context.annotation.Bean;\r\n\r\nimport java.util.logging.Logger;\r\n\r\n@SpringBootApplication\r\npublic class ParleyApplication extends SpringBootServletInitializer {\r\n    private static final Logger log = Logger.getLogger(ParleyApplication.class.getName());\r\n\r\n    public static void main(String[] args) {\r\n        SpringApplication.run(ParleyApplication.class, args);\r\n    }\r\n\r\n    @Bean\r\n    public CommandLineRunner commandLineRunner() {\r\n        return args -> {\r\n            // This code will run on startup\r\n            log.info(\"Application has started.\");\r\n        };\r\n    }\r\n}\r\n",
              "methods": [
                {
                  "name": "main",
                  "returnType": "public static void",
                  "parameters": [
                    "String[] args"
                  ],
                  "annotations": [
                    "@SpringBootApplication"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "commandLineRunner",
                  "returnType": "Bean\r\n    public CommandLineRunner",
                  "parameters": [],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                }
              ],
              "businessRules": [],
              "relatedClasses": [
                "SpringBootServletInitializer"
              ],
              "dependencies": []
            }
          ]
        },
        {
          "name": "org.sidequest.parley.security",
          "classes": [
            {
              "name": "JwtAuthenticationFilter",
              "path": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-service-jpa\\src\\main\\java\\org\\sidequest\\parley\\security\\JwtAuthenticationFilter.java",
              "type": "class",
              "imports": [
                "jakarta.servlet.FilterChain",
                "jakarta.servlet.ServletException",
                "jakarta.servlet.http.HttpServletRequest",
                "jakarta.servlet.http.HttpServletResponse",
                "lombok.RequiredArgsConstructor",
                "lombok.extern.slf4j.Slf4j",
                "org.springframework.security.authentication.UsernamePasswordAuthenticationToken",
                "org.springframework.security.core.context.SecurityContextHolder",
                "org.springframework.security.core.userdetails.UserDetails",
                "org.springframework.security.core.userdetails.UserDetailsService",
                "org.springframework.security.web.authentication.WebAuthenticationDetailsSource",
                "org.springframework.stereotype.Component",
                "org.springframework.web.filter.OncePerRequestFilter",
                "java.io.IOException"
              ],
              "annotations": [
                "@Slf4j",
                "@Component",
                "@RequiredArgsConstructor",
                "@Override",
                "@Override"
              ],
              "content": "package org.sidequest.parley.security;\r\n\r\nimport jakarta.servlet.FilterChain;\r\nimport jakarta.servlet.ServletException;\r\nimport jakarta.servlet.http.HttpServletRequest;\r\nimport jakarta.servlet.http.HttpServletResponse;\r\nimport lombok.RequiredArgsConstructor;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.springframework.security.authentication.UsernamePasswordAuthenticationToken;\r\nimport org.springframework.security.core.context.SecurityContextHolder;\r\nimport org.springframework.security.core.userdetails.UserDetails;\r\nimport org.springframework.security.core.userdetails.UserDetailsService;\r\nimport org.springframework.security.web.authentication.WebAuthenticationDetailsSource;\r\nimport org.springframework.stereotype.Component;\r\nimport org.springframework.web.filter.OncePerRequestFilter;\r\n\r\nimport java.io.IOException;\r\n\r\n/***\r\n SecurityConfig is important here. It is loaded before the filter is applied.\r\n ***/\r\n\r\n\r\n@Slf4j\r\n@Component\r\n@RequiredArgsConstructor\r\npublic class JwtAuthenticationFilter extends OncePerRequestFilter {\r\n\r\n    private final JwtTokenUtil jwtUtil;\r\n    private final UserDetailsService userDetailsService;\r\n\r\n    @Override\r\n    protected void doFilterInternal(\r\n            HttpServletRequest request,\r\n            HttpServletResponse response,\r\n            FilterChain filterChain\r\n    ) throws ServletException, IOException {\r\n        try {\r\n            // Enhanced request logging at the start\r\n            log.info(\"\\n\");\r\n            log.info(\"════════════════════════════════════════\");\r\n            log.info(\"JWT FILTER - PROCESSING REQUEST\");\r\n            log.info(\"════════════════════════════════════════\");\r\n            log.info(\"Request Method: {}\", request.getMethod());\r\n            log.info(\"Request URL: {}\", request.getRequestURL());\r\n            log.info(\"Request URI: {}\", request.getRequestURI());\r\n            log.info(\"Context Path: {}\", request.getContextPath());\r\n            log.info(\"Servlet Path: {}\", request.getServletPath());\r\n            log.info(\"Query String: {}\", request.getQueryString());\r\n\r\n            System.err.println(\"Request URL: \" + request.getRequestURL());\r\n\r\n            // Log all headers for debugging\r\n            java.util.Enumeration<String> headerNames = request.getHeaderNames();\r\n            while (headerNames.hasMoreElements()) {\r\n                String headerName = headerNames.nextElement();\r\n                log.debug(\"Header {}: {}\", headerName, request.getHeader(headerName));\r\n            }\r\n\r\n            final String authHeader = request.getHeader(\"Authorization\");\r\n            log.info(\"Authorization Header: {}\",\r\n                    authHeader != null ? authHeader.substring(0, Math.min(authHeader.length(), 20)) + \"...\" : \"null\");\r\n\r\n            if (authHeader == null || !authHeader.startsWith(\"Bearer \")) {\r\n                log.info(\"No valid Bearer token found - Proceeding with filter chain\");\r\n                filterChain.doFilter(request, response);\r\n                return;\r\n            }\r\n\r\n            final String jwt = authHeader.substring(7);\r\n            final String username = jwtUtil.getUsernameFromToken(jwt);\r\n            log.info(\"Extracted username from token: {}\", username);\r\n\r\n            if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {\r\n                UserDetails userDetails = this.userDetailsService.loadUserByUsername(username);\r\n                log.info(\"Retrieved user details for: {}\", username);\r\n\r\n                if (jwtUtil.validateToken(jwt)) {\r\n                    UsernamePasswordAuthenticationToken authToken = new UsernamePasswordAuthenticationToken(\r\n                            userDetails,\r\n                            null,\r\n                            userDetails.getAuthorities()\r\n                    );\r\n                    authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));\r\n                    SecurityContextHolder.getContext().setAuthentication(authToken);\r\n                    log.info(\"Successfully authenticated user: {}\", username);\r\n                } else {\r\n                    log.warn(\"Token validation failed for user: {}\", username);\r\n                }\r\n            }\r\n\r\n            filterChain.doFilter(request, response);\r\n            log.info(\"Filter chain completed for request: {}\", request.getRequestURI());\r\n            log.info(\"════════════════════════════════════════\\n\");\r\n\r\n        } catch (Exception e) {\r\n            log.error(\"JWT Authentication error for request {}: {}\", request.getRequestURI(), e.getMessage());\r\n            log.debug(\"Detailed exception: \", e);\r\n            filterChain.doFilter(request, response);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    protected boolean shouldNotFilter(HttpServletRequest request) {\r\n        String fullPath = request.getRequestURI();\r\n        String contextPath = request.getContextPath();\r\n        String path = fullPath.replace(contextPath, \"\");\r\n\r\n        log.info(\"\\n\");\r\n        log.info(\"╔══════════════════════════════════════\");\r\n        log.info(\"║ JWT FILTER - CHECKING PATH EXCLUSION\");\r\n        log.info(\"╠══════════════════════════════════════\");\r\n        log.info(\"║ Full Path: {}\", fullPath);\r\n        log.info(\"║ Context Path: {}\", contextPath);\r\n        log.info(\"║ Processed Path: {}\", path);\r\n\r\n        boolean result = path.contains(\"/swagger-ui\")\r\n                || path.contains(\"/api-docs\")\r\n                || path.contains(\"/auth/\")\r\n                || path.contains(\"META-INF\")\r\n                || path.contains(\"/auth/signup\")\r\n                || path.contains(\"/auth/login\")\r\n                || path.contains(\"/auth/logout\")\r\n                || path.contains(\"/parley/auth/signup\")\r\n                || path.contains(\"/parley/auth/login\")\r\n                || path.contains(\"/parley/auth/logout\")\r\n                || path.contains(\"/auth/password/reset\");\r\n\r\n        log.info(\"║ Filter Decision: {} will {} be filtered\", path, result ? \"NOT\" : \"\");\r\n        log.info(\"╚══════════════════════════════════════\\n\");\r\n\r\n        return result;\r\n    }\r\n}",
              "methods": [
                {
                  "name": "doFilterInternal",
                  "returnType": "Override\r\n    protected void",
                  "parameters": [
                    "HttpServletRequest request",
                    "HttpServletResponse response",
                    "FilterChain filterChain"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": [
                    "ServletException",
                    "IOException"
                  ]
                },
                {
                  "name": "shouldNotFilter",
                  "returnType": "Override\r\n    protected boolean",
                  "parameters": [
                    "HttpServletRequest request"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                }
              ],
              "businessRules": [
                "Enhanced request logging at the start\r\n            log.info(\"\\n\");\r\n            log.info(\"════════════════════════════════════════\");\r\n            log.info(\"JWT FILTER - PROCESSING REQUEST\");\r\n            log.info(\"════════════════════════════════════════\");\r\n            log.info(\"Request Method: {}\", request.getMethod());\r\n            log.info(\"Request URL: {}\", request.getRequestURL());\r\n            log.info(\"Request URI: {}\", request.getRequestURI());\r\n            log.info(\"Context Path: {}\", request.getContextPath());\r\n            log.info(\"Servlet Path: {}\", request.getServletPath());\r\n            log.info(\"Query String: {}\", request.getQueryString());\r\n\r\n            System.err.println(\"Request URL: \" + request.getRequestURL());\r\n\r\n            // Log all headers for debugging\r\n            java.util.Enumeration<String> headerNames = request.getHeaderNames();\r\n            while (headerNames.hasMoreElements()) {\r\n                String headerName = headerNames.nextElement();\r\n                log.debug(\"Header {}: {}\", headerName, request.getHeader(headerName));\r\n            }\r\n\r\n            final String authHeader = request.getHeader(\"Authorization\");\r\n            log.info(\"Authorization Header: {}\",\r\n                    authHeader != null ? authHeader.substring(0, Math.min(authHeader.length(), 20)) + \"...\" : \"null\");\r\n\r\n            if (authHeader == null || !authHeader.startsWith(\"Bearer \")) {\r\n                log.info(\"No valid Bearer token found - Proceeding with filter chain\");\r\n                filterChain.doFilter(request, response);\r\n                return;\r\n            }\r\n\r\n            final String jwt = authHeader.substring(7);\r\n            final String username = jwtUtil.getUsernameFromToken(jwt);\r\n            log.info(\"Extracted username from token: {}\", username);\r\n\r\n            if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {\r\n                UserDetails userDetails = this.userDetailsService.loadUserByUsername(username);\r\n                log.info(\"Retrieved user details for: {}\", username);\r\n\r\n                if (jwtUtil.validateToken(jwt)) {\r\n                    UsernamePasswordAuthenticationToken authToken = new UsernamePasswordAuthenticationToken(\r\n                            userDetails,\r\n                            null,\r\n                            userDetails.getAuthorities()\r\n                    );\r\n                    authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));\r\n                    SecurityContextHolder.getContext().setAuthentication(authToken);\r\n                    log.info(\"Successfully authenticated user: {}\", username);\r\n                } else {\r\n                    log.warn(\"Token validation failed for user: {}\", username);\r\n                }\r\n            }\r\n\r\n            filterChain.doFilter(request, response);\r\n            log.info(\"Filter chain completed for request: {}\", request.getRequestURI());\r\n            log.info(\"════════════════════════════════════════\\n\");\r\n\r\n        } catch (Exception e) {\r\n            log.error(\"JWT Authentication error for request {}: {}\", request.getRequestURI(), e.getMessage());\r\n            log.debug(\"Detailed exception: \", e);\r\n            filterChain.doFilter(request, response);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    protected boolean shouldNotFilter(HttpServletRequest request) {\r\n        String fullPath = request.getRequestURI();\r\n        String contextPath = request.getContextPath();\r\n        String path = fullPath.replace(contextPath, \"\");\r\n\r\n        log.info(\"\\n\");\r\n        log.info(\"╔══════════════════════════════════════\");\r\n        log.info(\"║ JWT FILTER - CHECKING PATH EXCLUSION\");\r\n        log.info(\"╠══════════════════════════════════════\");\r\n        log.info(\"║ Full Path: {}\", fullPath);\r\n        log.info(\"║ Context Path: {}\", contextPath);\r\n        log.info(\"║ Processed Path: {}\", path);\r\n\r\n        boolean result = path.contains(\"/swagger-ui\")\r\n                || path.contains(\"/api-docs\")\r\n                || path.contains(\"/auth/\")\r\n                || path.contains(\"META-INF\")\r\n                || path.contains(\"/auth/signup\")\r\n                || path.contains(\"/auth/login\")\r\n                || path.contains(\"/auth/logout\")\r\n                || path.contains(\"/parley/auth/signup\")\r\n                || path.contains(\"/parley/auth/login\")\r\n                || path.contains(\"/parley/auth/logout\")\r\n                || path.contains(\"/auth/password/reset\");\r\n\r\n        log.info(\"║ Filter Decision: {} will {} be filtered\", path, result ? \"NOT\" : \"\");\r\n        log.info(\"╚══════════════════════════════════════\\n\");\r\n\r\n        return result;\r\n    }\r\n}"
              ],
              "relatedClasses": [
                "OncePerRequestFilter"
              ],
              "dependencies": [
                "Spring Framework"
              ]
            },
            {
              "name": "JwtTokenUtil",
              "path": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-service-jpa\\src\\main\\java\\org\\sidequest\\parley\\security\\JwtTokenUtil.java",
              "type": "class",
              "imports": [
                "io.jsonwebtoken.Claims",
                "io.jsonwebtoken.JwtException",
                "io.jsonwebtoken.Jwts",
                "io.jsonwebtoken.security.Keys",
                "lombok.extern.slf4j.Slf4j",
                "org.springframework.beans.factory.annotation.Value",
                "org.springframework.stereotype.Component",
                "java.nio.charset.StandardCharsets",
                "java.security.Key",
                "java.util.Date",
                "java.util.HashMap",
                "java.util.Map",
                "java.util.function.Function"
              ],
              "annotations": [
                "@Slf4j",
                "@Component",
                "@Value(\"${jwt.secret}\")",
                "@Value(\"${jwt.expiration}\")"
              ],
              "content": "package org.sidequest.parley.security;\r\n\r\nimport io.jsonwebtoken.Claims;\r\nimport io.jsonwebtoken.JwtException;\r\nimport io.jsonwebtoken.Jwts;\r\nimport io.jsonwebtoken.security.Keys;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.springframework.beans.factory.annotation.Value;\r\nimport org.springframework.stereotype.Component;\r\n\r\nimport java.nio.charset.StandardCharsets;\r\nimport java.security.Key;\r\nimport java.util.Date;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\nimport java.util.function.Function;\r\n\r\n@Slf4j\r\n@Component\r\npublic class JwtTokenUtil {\r\n\r\n    @Value(\"${jwt.secret}\")\r\n    private String secret;\r\n\r\n    @Value(\"${jwt.expiration}\")\r\n    private Long expiration;\r\n\r\n    private Key getSigningKey() {\r\n        byte[] keyBytes = secret.getBytes(StandardCharsets.UTF_8);\r\n        return Keys.hmacShaKeyFor(keyBytes);\r\n    }\r\n\r\n    public String generateToken(String username, boolean rememberMe) {\r\n        Map<String, Object> claims = new HashMap<>();\r\n        long tokenExpiration = rememberMe ? expiration * 7 : expiration; // 7 days for remember me\r\n        return createToken(claims, username, tokenExpiration);\r\n    }\r\n\r\n    private String createToken(Map<String, Object> claims, String subject, long expiration) {\r\n        Date now = new Date();\r\n        Date expiryDate = new Date(now.getTime() + expiration);\r\n\r\n        return Jwts.builder()\r\n                .setClaims(claims)\r\n                .setSubject(subject)\r\n                .setIssuedAt(now)\r\n                .setExpiration(expiryDate)\r\n                .signWith(getSigningKey())  // SignatureAlgorithm.HS256 is now the default\r\n                .compact();\r\n    }\r\n\r\n    public Boolean validateToken(String token) {\r\n        if (token == null || token.isEmpty()) {\r\n            return false;\r\n        }\r\n\r\n        try {\r\n            Jwts.parserBuilder()\r\n                    .setSigningKey(getSigningKey())\r\n                    .build()\r\n                    .parseClaimsJws(token);\r\n            return !isTokenExpired(token);\r\n        } catch (JwtException e) {\r\n            log.warn(\"JWT token validation failed: {}\", e.getMessage());\r\n            return false;\r\n        } catch (Exception e) {\r\n            log.error(\"Unexpected error during token validation\", e);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public String getUsernameFromToken(String token) {\r\n        try {\r\n            return getClaimFromToken(token, Claims::getSubject);\r\n        } catch (JwtException e) {\r\n            log.warn(\"Failed to extract username from token: {}\", e.getMessage());\r\n            return null;\r\n        }\r\n    }\r\n\r\n    private Date getExpirationDateFromToken(String token) {\r\n        return getClaimFromToken(token, Claims::getExpiration);\r\n    }\r\n\r\n    private <T> T getClaimFromToken(String token, Function<Claims, T> claimsResolver) {\r\n        final Claims claims = getAllClaimsFromToken(token);\r\n        return claimsResolver.apply(claims);\r\n    }\r\n\r\n    private Claims getAllClaimsFromToken(String token) {\r\n        return Jwts.parserBuilder()\r\n                .setSigningKey(getSigningKey())\r\n                .build()\r\n                .parseClaimsJws(token)\r\n                .getBody();\r\n    }\r\n\r\n    private Boolean isTokenExpired(String token) {\r\n        try {\r\n            final Date expiration = getExpirationDateFromToken(token);\r\n            return expiration.before(new Date());\r\n        } catch (JwtException e) {\r\n            log.warn(\"Failed to check token expiration: {}\", e.getMessage());\r\n            return true;\r\n        }\r\n    }\r\n}",
              "methods": [
                {
                  "name": "getSigningKey",
                  "returnType": "private Key",
                  "parameters": [],
                  "annotations": [
                    "@Slf4j",
                    "@Component",
                    "@Value(\"${jwt.secret}\")",
                    "@Value(\"${jwt.expiration}\")"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "generateToken",
                  "returnType": "public String",
                  "parameters": [
                    "String username",
                    "boolean rememberMe"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "createToken",
                  "returnType": "7 days for remember me\r\n        return",
                  "parameters": [
                    "claims",
                    "username",
                    "tokenExpiration"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "createToken",
                  "returnType": "private String",
                  "parameters": [
                    "Map<String",
                    "Object> claims",
                    "String subject",
                    "long expiration"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "Date",
                  "returnType": "new",
                  "parameters": [],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "validateToken",
                  "returnType": "public Boolean",
                  "parameters": [
                    "String token"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "getUsernameFromToken",
                  "returnType": "public String",
                  "parameters": [
                    "String token"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "getClaimFromToken",
                  "returnType": "return",
                  "parameters": [
                    "token",
                    "Claims::getSubject"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "getExpirationDateFromToken",
                  "returnType": "private Date",
                  "parameters": [
                    "String token"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "getClaimFromToken",
                  "returnType": "return",
                  "parameters": [
                    "token",
                    "Claims::getExpiration"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "getClaimFromToken",
                  "returnType": "private <T> T",
                  "parameters": [
                    "String token",
                    "Function<Claims",
                    "T> claimsResolver"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "getAllClaimsFromToken",
                  "returnType": "private Claims",
                  "parameters": [
                    "String token"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "isTokenExpired",
                  "returnType": "private Boolean",
                  "parameters": [
                    "String token"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                }
              ],
              "businessRules": [
                "7 days for remember me\r\n        return createToken(claims, username, tokenExpiration);\r\n    }\r\n\r\n    private String createToken(Map<String, Object> claims, String subject, long expiration) {\r\n        Date now = new Date();\r\n        Date expiryDate = new Date(now.getTime() + expiration);\r\n\r\n        return Jwts.builder()\r\n                .setClaims(claims)\r\n                .setSubject(subject)\r\n                .setIssuedAt(now)\r\n                .setExpiration(expiryDate)\r\n                .signWith(getSigningKey())  // SignatureAlgorithm.HS256 is now the default\r\n                .compact();\r\n    }\r\n\r\n    public Boolean validateToken(String token) {\r\n        if (token == null || token.isEmpty()) {\r\n            return false;\r\n        }\r\n\r\n        try {\r\n            Jwts.parserBuilder()\r\n                    .setSigningKey(getSigningKey())\r\n                    .build()\r\n                    .parseClaimsJws(token);\r\n            return !isTokenExpired(token);\r\n        } catch (JwtException e) {\r\n            log.warn(\"JWT token validation failed: {}\", e.getMessage());\r\n            return false;\r\n        } catch (Exception e) {\r\n            log.error(\"Unexpected error during token validation\", e);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public String getUsernameFromToken(String token) {\r\n        try {\r\n            return getClaimFromToken(token, Claims::getSubject);\r\n        } catch (JwtException e) {\r\n            log.warn(\"Failed to extract username from token: {}\", e.getMessage());\r\n            return null;\r\n        }\r\n    }\r\n\r\n    private Date getExpirationDateFromToken(String token) {\r\n        return getClaimFromToken(token, Claims::getExpiration);\r\n    }\r\n\r\n    private <T> T getClaimFromToken(String token, Function<Claims, T> claimsResolver) {\r\n        final Claims claims = getAllClaimsFromToken(token);\r\n        return claimsResolver.apply(claims);\r\n    }\r\n\r\n    private Claims getAllClaimsFromToken(String token) {\r\n        return Jwts.parserBuilder()\r\n                .setSigningKey(getSigningKey())\r\n                .build()\r\n                .parseClaimsJws(token)\r\n                .getBody();\r\n    }\r\n\r\n    private Boolean isTokenExpired(String token) {\r\n        try {\r\n            final Date expiration = getExpirationDateFromToken(token);\r\n            return expiration.before(new Date());\r\n        } catch (JwtException e) {\r\n            log.warn(\"Failed to check token expiration: {}\", e.getMessage());\r\n            return true;\r\n        }\r\n    }\r\n}"
              ],
              "relatedClasses": [],
              "dependencies": [
                "Spring Framework"
              ]
            }
          ]
        },
        {
          "name": "org.sidequest.parley.handler",
          "classes": [
            {
              "name": "ValidationExceptionHandler",
              "path": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-service-jpa\\src\\main\\java\\org\\sidequest\\parley\\handler\\ValidationExceptionHandler.java",
              "type": "class",
              "imports": [
                "org.sidequest.parley.exception.ValidationException",
                "org.springframework.beans.factory.annotation.Autowired",
                "org.springframework.context.MessageSource",
                "org.springframework.http.HttpHeaders",
                "org.springframework.http.HttpStatus",
                "org.springframework.http.HttpStatusCode",
                "org.springframework.http.ResponseEntity",
                "org.springframework.web.bind.MethodArgumentNotValidException",
                "org.springframework.web.bind.annotation.ControllerAdvice",
                "org.springframework.web.bind.annotation.ExceptionHandler",
                "org.springframework.web.context.request.WebRequest",
                "org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler",
                "java.util.Date",
                "java.util.HashMap",
                "java.util.Locale",
                "java.util.Map"
              ],
              "annotations": [
                "@ControllerAdvice",
                "@Autowired",
                "@Override",
                "@ExceptionHandler(ValidationException.class)"
              ],
              "content": "package org.sidequest.parley.handler;\r\n\r\nimport org.sidequest.parley.exception.ValidationException;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.context.MessageSource;\r\nimport org.springframework.http.HttpHeaders;\r\nimport org.springframework.http.HttpStatus;\r\nimport org.springframework.http.HttpStatusCode;\r\nimport org.springframework.http.ResponseEntity;\r\nimport org.springframework.web.bind.MethodArgumentNotValidException;\r\nimport org.springframework.web.bind.annotation.ControllerAdvice;\r\nimport org.springframework.web.bind.annotation.ExceptionHandler;\r\nimport org.springframework.web.context.request.WebRequest;\r\nimport org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler;\r\n\r\nimport java.util.Date;\r\nimport java.util.HashMap;\r\nimport java.util.Locale;\r\nimport java.util.Map;\r\n\r\n@ControllerAdvice\r\npublic class ValidationExceptionHandler extends ResponseEntityExceptionHandler {\r\n\r\n    @Autowired\r\n    private MessageSource messageSource;\r\n\r\n    @Override\r\n    protected ResponseEntity<Object> handleMethodArgumentNotValid(\r\n            MethodArgumentNotValidException ex,\r\n            HttpHeaders headers,\r\n            HttpStatusCode status,\r\n            WebRequest request) {\r\n\r\n        Map<String, String> errors = new HashMap<>();\r\n        ex.getBindingResult().getFieldErrors().forEach(error -> {\r\n            String fieldName = error.getField();\r\n            String message = messageSource.getMessage(error.getDefaultMessage(), null, error.getDefaultMessage(), Locale.getDefault());\r\n            errors.put(fieldName, message);\r\n        });\r\n\r\n        Map<String, Object> body = new HashMap<>();\r\n        body.put(\"timestamp\", new Date());\r\n        body.put(\"status\", status.value());\r\n        body.put(\"errors\", errors);\r\n\r\n        return new ResponseEntity<>(body, headers, status);\r\n    }\r\n\r\n    @ExceptionHandler(ValidationException.class)\r\n    public ResponseEntity<Object> handleValidationException(ValidationException ex) {\r\n        Map<String, Object> body = new HashMap<>();\r\n        body.put(\"timestamp\", new Date());\r\n        body.put(\"status\", HttpStatus.BAD_REQUEST.value());\r\n\r\n        // Create error response\r\n        Map<String, Object> errorDetails = new HashMap<>();\r\n        errorDetails.put(\"code\", ex.getMessage());\r\n        errorDetails.put(\"message\", messageSource.getMessage(ex.getMessage(), null, ex.getMessage(), Locale.getDefault()));\r\n\r\n        body.put(\"error\", errorDetails);\r\n\r\n        return new ResponseEntity<>(body, HttpStatus.BAD_REQUEST);\r\n    }\r\n}",
              "methods": [
                {
                  "name": "handleMethodArgumentNotValid",
                  "returnType": "Override\r\n    protected ResponseEntity<Object>",
                  "parameters": [
                    "MethodArgumentNotValidException ex",
                    "HttpHeaders headers",
                    "HttpStatusCode status",
                    "WebRequest request"
                  ],
                  "annotations": [
                    "@ControllerAdvice",
                    "@Autowired"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "handleValidationException",
                  "returnType": "public ResponseEntity<Object>",
                  "parameters": [
                    "ValidationException ex"
                  ],
                  "annotations": [
                    "@ExceptionHandler(ValidationException.class)"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                }
              ],
              "businessRules": [],
              "relatedClasses": [
                "ResponseEntityExceptionHandler"
              ],
              "dependencies": [
                "Spring Framework"
              ]
            }
          ]
        },
        {
          "name": "org.sidequest.parley.service",
          "classes": [
            {
              "name": "AuthenticationService",
              "path": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-service-jpa\\src\\main\\java\\org\\sidequest\\parley\\service\\AuthenticationService.java",
              "type": "class",
              "imports": [
                "lombok.RequiredArgsConstructor",
                "lombok.extern.slf4j.Slf4j",
                "org.sidequest.parley.entity.UserEntity",
                "org.sidequest.parley.model.AuthRequest",
                "org.sidequest.parley.model.AuthResponse",
                "org.sidequest.parley.model.SignupRequest",
                "org.sidequest.parley.repository.UserRepository",
                "org.sidequest.parley.security.JwtTokenUtil",
                "org.sidequest.parley.util.EmailHelper",
                "org.sidequest.parley.util.TimeHelper",
                "org.springframework.beans.factory.annotation.Value",
                "org.springframework.security.authentication.AuthenticationManager",
                "org.springframework.security.authentication.UsernamePasswordAuthenticationToken",
                "org.springframework.security.core.Authentication",
                "org.springframework.security.core.context.SecurityContextHolder",
                "org.springframework.security.crypto.password.PasswordEncoder",
                "org.springframework.stereotype.Service",
                "org.springframework.transaction.annotation.Transactional",
                "java.time.OffsetDateTime",
                "java.util.UUID"
              ],
              "annotations": [
                "@Slf4j",
                "@Service",
                "@RequiredArgsConstructor",
                "@Value(\"${default.timezone}\")",
                "@Transactional",
                "@Transactional",
                "@Transactional",
                "@Transactional"
              ],
              "content": "package org.sidequest.parley.service;\r\n\r\nimport lombok.RequiredArgsConstructor;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.sidequest.parley.entity.UserEntity;\r\nimport org.sidequest.parley.model.AuthRequest;\r\nimport org.sidequest.parley.model.AuthResponse;\r\nimport org.sidequest.parley.model.SignupRequest;\r\nimport org.sidequest.parley.repository.UserRepository;\r\nimport org.sidequest.parley.security.JwtTokenUtil;\r\nimport org.sidequest.parley.util.EmailHelper;\r\nimport org.sidequest.parley.util.TimeHelper;\r\nimport org.springframework.beans.factory.annotation.Value;\r\nimport org.springframework.security.authentication.AuthenticationManager;\r\nimport org.springframework.security.authentication.UsernamePasswordAuthenticationToken;\r\nimport org.springframework.security.core.Authentication;\r\nimport org.springframework.security.core.context.SecurityContextHolder;\r\nimport org.springframework.security.crypto.password.PasswordEncoder;\r\nimport org.springframework.stereotype.Service;\r\nimport org.springframework.transaction.annotation.Transactional;\r\n\r\nimport java.time.OffsetDateTime;\r\nimport java.util.UUID;\r\n\r\n@Slf4j\r\n@Service\r\n@RequiredArgsConstructor\r\npublic class AuthenticationService {\r\n\r\n    private final AuthenticationManager authenticationManager;\r\n    private final JwtTokenUtil jwtTokenUtil;\r\n    private final UserRepository userRepository;\r\n    private final PasswordEncoder passwordEncoder;\r\n    private final EmailHelper emailHelper;\r\n\r\n    @Value(\"${default.timezone}\")\r\n    private String defaultTimezone;\r\n\r\n    public AuthResponse authenticate(AuthRequest request) {\r\n        Authentication authentication = authenticationManager.authenticate(\r\n                new UsernamePasswordAuthenticationToken(request.getUsername(), request.getPassword())\r\n        );\r\n\r\n        SecurityContextHolder.getContext().setAuthentication(authentication);\r\n        UserEntity user = (UserEntity) authentication.getPrincipal();\r\n        String token = jwtTokenUtil.generateToken(user.getUsername(), request.getRememberMe());\r\n\r\n        return new AuthResponse()\r\n                .token(token)\r\n                .tokenType(\"Bearer\")\r\n                .expiresIn(request.getRememberMe() ? 604800 : 86400); // 7 days : 1 day\r\n    }\r\n\r\n    public AuthResponse refreshToken(String token) {\r\n        String username = jwtTokenUtil.getUsernameFromToken(token);\r\n        UserEntity user = userRepository.findByName(username).orElseThrow(\r\n                () -> new IllegalArgumentException(\"User not found\")\r\n        );\r\n\r\n        if (jwtTokenUtil.validateToken(token)) {\r\n            String newToken = jwtTokenUtil.generateToken(user.getUsername(), false);\r\n\r\n            return new AuthResponse()\r\n                    .token(newToken)\r\n                    .tokenType(\"Bearer\")\r\n                    .expiresIn(86400);\r\n        } else {\r\n            throw new IllegalArgumentException(\"Invalid token\");\r\n        }\r\n    }\r\n\r\n    @Transactional\r\n    public void initiatePasswordReset(String email) {\r\n        UserEntity user = userRepository.findByEmail(email)\r\n                .orElseThrow(() -> new IllegalArgumentException(\"No user found with this email address\"));\r\n\r\n        String resetToken = UUID.randomUUID().toString();\r\n        OffsetDateTime expiration = OffsetDateTime.now().plusHours(24);\r\n\r\n        userRepository.updatePasswordResetToken(email, resetToken, expiration);\r\n        emailHelper.sendPasswordResetEmail(email, resetToken);\r\n    }\r\n\r\n    @Transactional\r\n    public void resetPassword(String token, String newPassword) {\r\n        UserEntity user = userRepository.findByPasswordResetToken(token)\r\n                .orElseThrow(() -> new IllegalArgumentException(\"Invalid or expired reset token\"));\r\n\r\n        if (user.getPasswordResetTokenExpiration().isBefore(OffsetDateTime.now())) {\r\n            throw new IllegalArgumentException(\"Reset token has expired\");\r\n        }\r\n\r\n        user.setMagic(passwordEncoder.encode(newPassword));\r\n        user.setPasswordResetToken(null);\r\n        user.setPasswordResetTokenExpiration(null);\r\n        userRepository.save(user);\r\n    }\r\n\r\n    @Transactional\r\n    public void changePassword(String username, String currentPassword, String newPassword) {\r\n        UserEntity user = userRepository.findByName(username)\r\n                .orElseThrow(() -> new IllegalArgumentException(\"User not found\"));\r\n\r\n        // Verify current password\r\n        if (!passwordEncoder.matches(currentPassword, user.getMagic())) {\r\n            throw new IllegalArgumentException(\"Current password is incorrect\");\r\n        }\r\n\r\n        // Update password\r\n        user.setMagic(passwordEncoder.encode(newPassword));\r\n        userRepository.save(user);\r\n    }\r\n\r\n    @Transactional\r\n    public AuthResponse signup(SignupRequest request) {\r\n        TimeHelper timeHelper = new TimeHelper();\r\n\r\n        // Validate passwords match\r\n        if (!request.getPassword().equals(request.getConfirmPassword())) {\r\n            throw new IllegalArgumentException(\"Passwords do not match\");\r\n        }\r\n\r\n        // Check if username exists\r\n        if (userRepository.existsByName(request.getUsername())) {\r\n            throw new IllegalArgumentException(\"Username already exists\");\r\n        }\r\n\r\n        // Check if email exists\r\n        if (userRepository.existsByEmail(request.getEmail())) {\r\n            throw new IllegalArgumentException(\"Email already exists\");\r\n        }\r\n\r\n        // Create new user\r\n        UserEntity user = new UserEntity();\r\n        user.setName(request.getUsername());\r\n        user.setEmail(request.getEmail());\r\n        user.setMagic(passwordEncoder.encode(request.getPassword()));\r\n        user.setTimezone(timeHelper.isTimezone(request.getTimezone()) ? request.getTimezone() : defaultTimezone);\r\n\r\n\r\n        userRepository.save(user);\r\n        log.info(\"Created new user: \" + user.getName());\r\n\r\n        // Generate JWT token\r\n        String token = jwtTokenUtil.generateToken(user.getUsername(), false);\r\n\r\n        return new AuthResponse()\r\n                .token(token)\r\n                .tokenType(\"Bearer\")\r\n                .expiresIn(86400); // 1 day\r\n    }\r\n}",
              "methods": [
                {
                  "name": "authenticate",
                  "returnType": "public AuthResponse",
                  "parameters": [
                    "AuthRequest request"
                  ],
                  "annotations": [
                    "@Value(\"${default.timezone}\")"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "refreshToken",
                  "returnType": "public AuthResponse",
                  "parameters": [
                    "String token"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "IllegalArgumentException",
                  "returnType": "throw new",
                  "parameters": [
                    "\"Invalid token\""
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "initiatePasswordReset",
                  "returnType": "Transactional\r\n    public void",
                  "parameters": [
                    "String email"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "resetPassword",
                  "returnType": "Transactional\r\n    public void",
                  "parameters": [
                    "String token",
                    "String newPassword"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "IllegalArgumentException",
                  "returnType": "throw new",
                  "parameters": [
                    "\"Reset token has expired\""
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "changePassword",
                  "returnType": "Transactional\r\n    public void",
                  "parameters": [
                    "String username",
                    "String currentPassword",
                    "String newPassword"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "IllegalArgumentException",
                  "returnType": "throw new",
                  "parameters": [
                    "\"Current password is incorrect\""
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "signup",
                  "returnType": "Transactional\r\n    public AuthResponse",
                  "parameters": [
                    "SignupRequest request"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "TimeHelper",
                  "returnType": "new",
                  "parameters": [],
                  "annotations": [
                    "@Transactional"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "IllegalArgumentException",
                  "returnType": "throw new",
                  "parameters": [
                    "\"Passwords do not match\""
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "IllegalArgumentException",
                  "returnType": "throw new",
                  "parameters": [
                    "\"Username already exists\""
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "IllegalArgumentException",
                  "returnType": "throw new",
                  "parameters": [
                    "\"Email already exists\""
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "UserEntity",
                  "returnType": "new",
                  "parameters": [],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                }
              ],
              "businessRules": [],
              "relatedClasses": [],
              "dependencies": [
                "Spring Framework"
              ]
            },
            {
              "name": "ChatMessageService",
              "path": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-service-jpa\\src\\main\\java\\org\\sidequest\\parley\\service\\ChatMessageService.java",
              "type": "class",
              "imports": [
                "org.sidequest.parley.entity.ChatMessageEntity",
                "org.sidequest.parley.entity.ChatRoomEntity",
                "org.sidequest.parley.mapper.ChatMessageMapper",
                "org.sidequest.parley.model.ChatMessage",
                "org.sidequest.parley.model.NewChatMessage",
                "org.sidequest.parley.repository.ChatMessageRepository",
                "org.springframework.beans.factory.annotation.Autowired",
                "org.springframework.context.annotation.Lazy",
                "org.springframework.stereotype.Service",
                "org.springframework.transaction.annotation.Transactional",
                "java.sql.SQLException",
                "java.time.OffsetDateTime",
                "java.util.List",
                "java.util.logging.Logger",
                "java.util.stream.Collectors"
              ],
              "annotations": [
                "@Service",
                "@Autowired",
                "@Autowired",
                "@Autowired",
                "@Lazy",
                "@Autowired",
                "@Lazy",
                "@Transactional"
              ],
              "content": "package org.sidequest.parley.service;\r\n\r\nimport org.sidequest.parley.entity.ChatMessageEntity;\r\nimport org.sidequest.parley.entity.ChatRoomEntity;\r\nimport org.sidequest.parley.mapper.ChatMessageMapper;\r\nimport org.sidequest.parley.model.ChatMessage;\r\nimport org.sidequest.parley.model.NewChatMessage;\r\nimport org.sidequest.parley.repository.ChatMessageRepository;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.context.annotation.Lazy;\r\nimport org.springframework.stereotype.Service;\r\nimport org.springframework.transaction.annotation.Transactional;\r\n\r\nimport java.sql.SQLException;\r\nimport java.time.OffsetDateTime;\r\nimport java.util.List;\r\nimport java.util.logging.Logger;\r\nimport java.util.stream.Collectors;\r\n\r\n@Service\r\npublic class ChatMessageService {\r\n    private static final Logger log = Logger.getLogger(ChatMessageService.class.getName());\r\n\r\n    private ChatMessageRepository chatMessageRepository;\r\n\r\n\r\n    private UserService userService;\r\n    private ChatRoomService chatRoomService;\r\n    private EnrollmentService enrollmentService;\r\n\r\n    @Autowired\r\n    public void setChatMessageRepository(ChatMessageRepository chatMessageRepository) {\r\n        this.chatMessageRepository = chatMessageRepository;\r\n    }\r\n\r\n    @Autowired\r\n    public void setEnrollmentService(EnrollmentService enrollmentService) {\r\n        this.enrollmentService = enrollmentService;\r\n    }\r\n\r\n    @Autowired\r\n    public void setChatRoomService(@Lazy ChatRoomService chatRoomService) {\r\n        this.chatRoomService = chatRoomService;\r\n    }\r\n\r\n    @Autowired\r\n    public void setUserService(@Lazy UserService userService) {\r\n        this.userService = userService;\r\n    }\r\n\r\n    public List<ChatMessage> getChatMessages() {\r\n        return chatMessageRepository.findAll().stream().map(ChatMessageMapper.INSTANCE::toModel).collect(Collectors.toList());\r\n    }\r\n\r\n    public ChatMessage getChatMessage(Long id) {\r\n        ChatMessage chatMessage = chatMessageRepository.findById(id).map(ChatMessageMapper.INSTANCE::toModel).orElse(null);\r\n        log.fine(\"getChatMessage: \" + chatMessage);\r\n\r\n        if (chatMessage == null) {\r\n            return null;\r\n        }\r\n\r\n\r\n        return chatMessage;\r\n    }\r\n\r\n    @Transactional\r\n    public ChatMessage createChatMessage(NewChatMessage newChatMessage) throws SQLException {\r\n        log.info(\"createChatMessage: \" + newChatMessage.toString());\r\n\r\n        // We get the current time in OffsetDateTime format\r\n        // The mapper will convert it to UTC for storage in the database\r\n        // The mapper will convert it back to the user's timezone when the chat message is retrieved\r\n        OffsetDateTime odt = OffsetDateTime.now();\r\n\r\n        Long chatRoomId = newChatMessage.getChatRoomId();\r\n        Long userId = newChatMessage.getUserId();\r\n\r\n        // Check if the user is a member of the chat room\r\n        if (enrollmentService.isUserInChatRoom(userId, chatRoomId)) {\r\n            log.info(\"User is a member of the chat room\");\r\n        } else {\r\n            throw new RuntimeException(\"Access denied: User is not a member of the chat room\");\r\n        }\r\n\r\n        // Retrieve the managed ChatRoomEntity\r\n        ChatRoomEntity chatRoomEntity = chatRoomService.getChatRoomEntity(chatRoomId);\r\n        if (chatRoomEntity == null) {\r\n            throw new RuntimeException(\"Chat room not found\");\r\n        }\r\n        // Retrieve the user's timezone\r\n        //  String strUserTimezone = userService.getUserTimezone(userId);\r\n        // log.fine(\"User timezone: \" + strUserTimezone);\r\n\r\n        // Create and set up the ChatMessageEntity\r\n        ChatMessageEntity chatMessageEntity = new ChatMessageEntity();\r\n        chatMessageEntity.setChatRoom(chatRoomEntity);\r\n        chatMessageEntity.setUser(userService.getUserEntity(userId));\r\n        chatMessageEntity.setContent(newChatMessage.getContent());\r\n        chatMessageEntity.setScreenEffect(newChatMessage.getScreenEffect());\r\n        chatMessageEntity.setTextEffect(newChatMessage.getTextEffect());\r\n        chatMessageEntity.setTimestamp(odt);\r\n\r\n        log.info(\"Saving chat message: \" + chatMessageEntity);\r\n        chatMessageEntity = chatMessageRepository.saveAndFlush(chatMessageEntity);\r\n        log.info(\"Chat message saved...\");\r\n\r\n        userService.updateLastPostedMessageDateTime(userId, odt);\r\n        return ChatMessageMapper.INSTANCE.toModel(chatMessageEntity);\r\n    }\r\n\r\n\r\n    public List<ChatMessage> getChatMessagesByChatRoomId(Long chatRoomId) {\r\n        List<ChatMessageEntity> chatMessageEntities = chatMessageRepository.findByChatRoomId(chatRoomId);\r\n        List<ChatMessage> chatMessages = chatMessageEntities.stream().map(ChatMessageMapper.INSTANCE::toModel).collect(Collectors.toList());\r\n        for (ChatMessage chatMessage : chatMessages) {\r\n            chatMessage.setChatRoom(null);\r\n        }\r\n\r\n        return chatMessages;\r\n    }\r\n}",
              "methods": [
                {
                  "name": "setChatMessageRepository",
                  "returnType": "Autowired\r\n    public void",
                  "parameters": [
                    "ChatMessageRepository chatMessageRepository"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "setEnrollmentService",
                  "returnType": "Autowired\r\n    public void",
                  "parameters": [
                    "EnrollmentService enrollmentService"
                  ],
                  "annotations": [
                    "@Autowired"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "setChatRoomService",
                  "returnType": "Autowired\r\n    public void",
                  "parameters": [
                    "@Lazy ChatRoomService chatRoomService"
                  ],
                  "annotations": [
                    "@Autowired"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "setUserService",
                  "returnType": "Autowired\r\n    public void",
                  "parameters": [
                    "@Lazy UserService userService"
                  ],
                  "annotations": [
                    "@Autowired"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "getChatMessages",
                  "returnType": "public List<ChatMessage>",
                  "parameters": [],
                  "annotations": [
                    "@Autowired"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "getChatMessage",
                  "returnType": "public ChatMessage",
                  "parameters": [
                    "Long id"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "if",
                  "returnType": "",
                  "parameters": [
                    "chatMessage == null"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "createChatMessage",
                  "returnType": "Transactional\r\n    public ChatMessage",
                  "parameters": [
                    "NewChatMessage newChatMessage"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": [
                    "SQLException"
                  ]
                },
                {
                  "name": "RuntimeException",
                  "returnType": "throw new",
                  "parameters": [
                    "\"Access denied: User is not a member of the chat room\""
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "if",
                  "returnType": "",
                  "parameters": [
                    "chatRoomEntity == null"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "RuntimeException",
                  "returnType": "throw new",
                  "parameters": [
                    "\"Chat room not found\""
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "ChatMessageEntity",
                  "returnType": "new",
                  "parameters": [],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "getChatMessagesByChatRoomId",
                  "returnType": "public List<ChatMessage>",
                  "parameters": [
                    "Long chatRoomId"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "for",
                  "returnType": "",
                  "parameters": [
                    "ChatMessage chatMessage : chatMessages"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                }
              ],
              "businessRules": [],
              "relatedClasses": [],
              "dependencies": [
                "Spring Framework"
              ]
            },
            {
              "name": "ChatRoomService",
              "path": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-service-jpa\\src\\main\\java\\org\\sidequest\\parley\\service\\ChatRoomService.java",
              "type": "class",
              "imports": [
                "org.sidequest.parley.entity.ChatRoomEntity",
                "org.sidequest.parley.entity.UserEntity",
                "org.sidequest.parley.mapper.ChatRoomMapper",
                "org.sidequest.parley.model.ChatMessage",
                "org.sidequest.parley.model.ChatRoom",
                "org.sidequest.parley.model.NewChatRoom",
                "org.sidequest.parley.model.User",
                "org.sidequest.parley.repository.ChatRoomRepository",
                "org.sidequest.parley.util.FileSystemHelper",
                "org.springframework.beans.factory.annotation.Autowired",
                "org.springframework.beans.factory.annotation.Value",
                "org.springframework.context.annotation.Lazy",
                "org.springframework.stereotype.Service",
                "org.springframework.transaction.annotation.Transactional",
                "org.springframework.web.multipart.MultipartFile",
                "java.util.ArrayList",
                "java.util.HashSet",
                "java.util.List",
                "java.util.Set",
                "java.util.logging.Level",
                "java.util.logging.Logger"
              ],
              "annotations": [
                "@Service",
                "@Autowired",
                "@Autowired",
                "@Autowired",
                "@Value(\"${chatroom.icon.directory}\")",
                "@Autowired",
                "@Autowired",
                "@Lazy",
                "@Autowired",
                "@Lazy",
                "@Autowired",
                "@Transactional",
                "@Transactional",
                "@Transactional"
              ],
              "content": "package org.sidequest.parley.service;\r\n\r\nimport org.sidequest.parley.entity.ChatRoomEntity;\r\nimport org.sidequest.parley.entity.UserEntity;\r\nimport org.sidequest.parley.mapper.ChatRoomMapper;\r\nimport org.sidequest.parley.model.ChatMessage;\r\nimport org.sidequest.parley.model.ChatRoom;\r\nimport org.sidequest.parley.model.NewChatRoom;\r\nimport org.sidequest.parley.model.User;\r\nimport org.sidequest.parley.repository.ChatRoomRepository;\r\nimport org.sidequest.parley.util.FileSystemHelper;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.beans.factory.annotation.Value;\r\nimport org.springframework.context.annotation.Lazy;\r\nimport org.springframework.stereotype.Service;\r\nimport org.springframework.transaction.annotation.Transactional;\r\nimport org.springframework.web.multipart.MultipartFile;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.HashSet;\r\nimport java.util.List;\r\nimport java.util.Set;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\n\r\n@Service\r\npublic class ChatRoomService {\r\n    private static final Logger log = Logger.getLogger(ChatRoomService.class.getName());\r\n\r\n    private ChatRoomRepository chatRoomRepository;\r\n\r\n    // @Autowired\r\n    private EnrollmentService enrollmentService;\r\n    //@Autowired\r\n    private UserService userService;\r\n\r\n    @Autowired\r\n    private FileSystemHelper fileSystemHelper;\r\n\r\n    @Value(\"${chatroom.icon.directory}\")\r\n    private String chatroomIconDirectory;\r\n    @Autowired\r\n    private ChatMessageService chatMessageService;\r\n\r\n    @Autowired\r\n    public void setEnrollmentService(@Lazy EnrollmentService enrollmentService) {\r\n        this.enrollmentService = enrollmentService;\r\n    }\r\n\r\n    @Autowired\r\n    public void setUserService(@Lazy UserService userService) {\r\n        this.userService = userService;\r\n    }\r\n\r\n    @Autowired\r\n    public void setChatRoomRepository(ChatRoomRepository chatRoomRepository) {\r\n        this.chatRoomRepository = chatRoomRepository;\r\n    }\r\n\r\n\r\n    public List<ChatRoom> getChatRooms() {\r\n        log.info(\"Attempting to retrieve all chat rooms\");\r\n        List<ChatRoom> chatRooms = new ArrayList<>();\r\n        List<ChatRoomEntity> chatRoomEntities = chatRoomRepository.findAll();\r\n        for (ChatRoomEntity chatRoomEntity : chatRoomEntities) {\r\n            log.info(\"chatRoom: \" + chatRoomEntity.getName() + \" (\" + chatRoomEntity.getId() + \")\");\r\n            ChatRoom chatRoom = ChatRoomMapper.INSTANCE.toModel(chatRoomEntity);\r\n            // We need to get the enrolled users for the chat room\r\n            // Then we add the users to the chat room\r\n            enrollmentService.getChatRoomByUserIds(chatRoomEntity.getId()).forEach(userId -> {\r\n                chatRoom.addUsersItem(userService.getUser(userId));\r\n            });\r\n\r\n            chatRooms.add(chatRoom);\r\n        }\r\n        log.info(\"Retrieved all chatrooms size: \" + chatRooms.size());\r\n        return chatRooms;\r\n    }\r\n\r\n    public ChatRoom getChatRoom(Long id) {\r\n        log.info(\"Attempting to retrieve chat room with id \" + id);\r\n        ChatRoom chatRoom = chatRoomRepository.findById(id)\r\n                .map(ChatRoomMapper.INSTANCE::toModel).orElse(null);\r\n\r\n        if (chatRoom == null) {\r\n            log.severe(\"Chat room with id \" + id + \" not found\");\r\n            return null;\r\n        }\r\n\r\n        // We need to get the enrolled users for the chat room\r\n        // Then we add the users to the chat room\r\n        enrollmentService.getChatRoomByUserIds(id).forEach(userId -> {\r\n            chatRoom.addUsersItem(userService.getUser(userId));\r\n        });\r\n\r\n        log.info(\"Chat room: \" + chatRoom.getName() + \" (\" + chatRoom.getChatRoomId() + \") has \" + chatRoom.getUsers().size() + \" users\");\r\n        log.info(\"Successfully retrieved chat room with id \" + id);\r\n        return chatRoom;\r\n    }\r\n\r\n    @Transactional\r\n    public ChatRoom createChatRoom(NewChatRoom newChatRoom) {\r\n        try {\r\n            log.info(\"Attempting to create chat room: \" + newChatRoom.getName());\r\n            // Validate new chat room details\r\n            if (newChatRoom == null || newChatRoom.getName() == null || newChatRoom.getName().isEmpty()) {\r\n                log.warning(\"Invalid chat room details provided.\");\r\n                throw new IllegalArgumentException(\"Chat room name cannot be null or empty.\");\r\n            }\r\n\r\n            if (newChatRoom.getModerator() == null || newChatRoom.getModerator().getId() == null) {\r\n                throw new IllegalArgumentException(\"Moderator ID cannot be null.\");\r\n            }\r\n\r\n            UserEntity moderator;\r\n            try {\r\n                moderator = userService.getUserEntity(newChatRoom.getModerator().getId());\r\n                if (moderator == null) {\r\n                    throw new IllegalArgumentException(\"Moderator not found with ID: \" + newChatRoom.getModerator().getId());\r\n                }\r\n            } catch (RuntimeException e) {\r\n                throw new IllegalArgumentException(\"Invalid moderator ID: \" + newChatRoom.getModerator().getId());\r\n            }\r\n\r\n\r\n            // Create and save the new chat room entity\r\n            ChatRoomEntity chatRoomEntity = new ChatRoomEntity();\r\n            chatRoomEntity.setName(newChatRoom.getName());\r\n            chatRoomEntity.setModerator(moderator);\r\n\r\n            // Save and flush to get the id\r\n            // if you just save, the id will be null because the entity manager has not persisted the entity yet\r\n            // to the database. The flush method forces the entity manager to persist the entity to the database.\r\n            // This is useful when you need the id of the entity immediately after saving it.\r\n            // If you don't need the id immediately, you can just call save.\r\n            // https://www.baeldung.com/spring-data-jpa-save-saveandflush\r\n            log.info(\"Saving chat room entity: \" + chatRoomEntity.getName());\r\n            ChatRoomEntity resultChatroomEntity = chatRoomRepository.saveAndFlush(chatRoomEntity);\r\n\r\n            log.info(\"Chat room entity created: \" + resultChatroomEntity.getName() + \" (\" + resultChatroomEntity.getId() + \")\");\r\n\r\n            ChatRoom resultChatroom = ChatRoomMapper.INSTANCE.toModel(resultChatroomEntity);\r\n\r\n            // Add the users to the chatroom including the moderator\r\n            Set<User> userSet = new HashSet<>(newChatRoom.getUsers());\r\n            userSet.add(newChatRoom.getModerator());\r\n            List<User> uniqueUsers = new ArrayList<>(userSet);\r\n\r\n            enrollmentService.addUsersToChatRoom(uniqueUsers, resultChatroom);\r\n\r\n            log.info(\"Chat room created successfully: \" + resultChatroom.getName());\r\n            return getChatRoom(resultChatroom.getChatRoomId());\r\n\r\n        } catch (Exception e) {\r\n            log.log(Level.SEVERE, \"Failed to create chat room: \" + newChatRoom.getName(), e);\r\n            throw new RuntimeException(\"Failed to create chat room: \" + newChatRoom.getName(), e);\r\n        }\r\n    }\r\n\r\n\r\n    @Transactional\r\n    public ChatRoom updateChatRoom(Long id, ChatRoom chatRoom) {\r\n        log.info(\"Attempting to update chat room with id \" + id);\r\n        ChatRoomEntity chatRoomEntity = chatRoomRepository.findById(id)\r\n                .orElseThrow(() -> new IllegalArgumentException(\"Chat room with id \" + id + \" not found\"));\r\n\r\n        // Update the chat room details\r\n        chatRoomEntity.setName(chatRoom.getName());\r\n        chatRoomEntity.setModerator(userService.getUserEntity(chatRoom.getModerator().getId()));\r\n        chatRoomRepository.saveAndFlush(chatRoomEntity); // Save and flush to persist to the database\r\n\r\n        // Remove all users from the chat room and add the new users\r\n        enrollmentService.removeUsersFromChatRoom(id);\r\n        enrollmentService.addUsersToChatRoom(chatRoom.getUsers(), chatRoom);\r\n\r\n        log.info(\"Successfully updated chat room with id \" + id);\r\n        return getChatRoom(id);\r\n    }\r\n\r\n    public boolean isUserInChatRoom(Long userId, Long chatRoomId) {\r\n        log.info(\"Checking if user: \" + userId + \" is in chat room: \" + chatRoomId);\r\n        ChatRoom chatRoom = getChatRoom(chatRoomId);\r\n        if (chatRoom == null) {\r\n            log.severe(\"Chat room with id \" + chatRoomId + \" not found\");\r\n            return false;\r\n        }\r\n\r\n        for (User user : chatRoom.getUsers()) {\r\n            if (user.getId().equals(userId)) {\r\n                log.info(\"User: \" + userId + \" is in chat room: \" + chatRoomId);\r\n                return true;\r\n            }\r\n        }\r\n\r\n        log.info(\"User: \" + userId + \" is not in chat room: \" + chatRoomId);\r\n        return false;\r\n    }\r\n\r\n    public String getChatRoomIcon(Long id) throws Exception {\r\n        ChatRoomEntity chatRoomEntity = chatRoomRepository.findById(id).orElseThrow(() -> new Exception(\"Chatroom not found\"));\r\n        return chatRoomEntity.getIconPath();\r\n    }\r\n\r\n    @Transactional\r\n    public void setChatRoomIcon(Long chatroomId, MultipartFile iconFile) throws Exception {\r\n        if (!iconFile.isEmpty()) {\r\n            log.fine(\"Saving icon for chatroom: \" + chatroomId);\r\n            ChatRoomEntity chatRoomEntity = chatRoomRepository.findById(chatroomId).orElseThrow(() -> new Exception(\"Chatroom not found\"));\r\n            String path = fileSystemHelper.saveFile(iconFile, chatroomIconDirectory);\r\n            chatRoomEntity.setIconPath(path);\r\n            chatRoomRepository.save(chatRoomEntity);\r\n        } else {\r\n            log.severe(\"Empty file!\");\r\n            throw new Exception(\"Empty file!\");\r\n        }\r\n    }\r\n\r\n    public void deleteChatRoom(Long id) {\r\n        log.info(\"Attempting to delete chat room with id \" + id);\r\n        chatRoomRepository.deleteById(id);\r\n        log.info(\"Successfully deleted chat room with id \" + id);\r\n    }\r\n\r\n    public ChatRoomEntity getChatRoomEntity(Long chatRoomId) {\r\n        log.info(\"Attempting to retrieve ChatRoomEntity with id \" + chatRoomId);\r\n\r\n        ChatRoomEntity chatRoomEntity = chatRoomRepository.findById(chatRoomId)\r\n                .orElse(null);\r\n\r\n        if (chatRoomEntity == null) {\r\n            log.warning(\"ChatRoomEntity with id \" + chatRoomId + \" not found\");\r\n            return null;\r\n        }\r\n\r\n        log.info(\"Successfully retrieved ChatRoomEntity with id \" + chatRoomId);\r\n        return chatRoomEntity;\r\n    }\r\n\r\n    public List<ChatMessage> getChatroomChatsByChatRoomId(Long chatRoomId) {\r\n        return chatMessageService.getChatMessagesByChatRoomId(chatRoomId);\r\n    }\r\n}",
              "methods": [
                {
                  "name": "setEnrollmentService",
                  "returnType": "Autowired\r\n    public void",
                  "parameters": [
                    "@Lazy EnrollmentService enrollmentService"
                  ],
                  "annotations": [
                    "@Value(\"${chatroom.icon.directory}\")",
                    "@Autowired"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "setUserService",
                  "returnType": "Autowired\r\n    public void",
                  "parameters": [
                    "@Lazy UserService userService"
                  ],
                  "annotations": [
                    "@Autowired"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "setChatRoomRepository",
                  "returnType": "Autowired\r\n    public void",
                  "parameters": [
                    "ChatRoomRepository chatRoomRepository"
                  ],
                  "annotations": [
                    "@Autowired"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "getChatRooms",
                  "returnType": "public List<ChatRoom>",
                  "parameters": [],
                  "annotations": [
                    "@Autowired"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "for",
                  "returnType": "",
                  "parameters": [
                    "ChatRoomEntity chatRoomEntity : chatRoomEntities"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "getChatRoom",
                  "returnType": "public ChatRoom",
                  "parameters": [
                    "Long id"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "if",
                  "returnType": "",
                  "parameters": [
                    "chatRoom == null"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "createChatRoom",
                  "returnType": "Transactional\r\n    public ChatRoom",
                  "parameters": [
                    "NewChatRoom newChatRoom"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "IllegalArgumentException",
                  "returnType": "throw new",
                  "parameters": [
                    "\"Chat room name cannot be null or empty.\""
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "IllegalArgumentException",
                  "returnType": "throw new",
                  "parameters": [
                    "\"Moderator ID cannot be null.\""
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "if",
                  "returnType": "",
                  "parameters": [
                    "moderator == null"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "ChatRoomEntity",
                  "returnType": "new",
                  "parameters": [],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "updateChatRoom",
                  "returnType": "Transactional\r\n    public ChatRoom",
                  "parameters": [
                    "Long id",
                    "ChatRoom chatRoom"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "getChatRoom",
                  "returnType": "return",
                  "parameters": [
                    "id"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "isUserInChatRoom",
                  "returnType": "public boolean",
                  "parameters": [
                    "Long userId",
                    "Long chatRoomId"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "if",
                  "returnType": "",
                  "parameters": [
                    "chatRoom == null"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "getChatRoomIcon",
                  "returnType": "public String",
                  "parameters": [
                    "Long id"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": [
                    "Exception"
                  ]
                },
                {
                  "name": "setChatRoomIcon",
                  "returnType": "Transactional\r\n    public void",
                  "parameters": [
                    "Long chatroomId",
                    "MultipartFile iconFile"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": [
                    "Exception"
                  ]
                },
                {
                  "name": "Exception",
                  "returnType": "throw new",
                  "parameters": [
                    "\"Empty file!\""
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "deleteChatRoom",
                  "returnType": "public void",
                  "parameters": [
                    "Long id"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "getChatRoomEntity",
                  "returnType": "public ChatRoomEntity",
                  "parameters": [
                    "Long chatRoomId"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "if",
                  "returnType": "",
                  "parameters": [
                    "chatRoomEntity == null"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "getChatroomChatsByChatRoomId",
                  "returnType": "public List<ChatMessage>",
                  "parameters": [
                    "Long chatRoomId"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                }
              ],
              "businessRules": [],
              "relatedClasses": [],
              "dependencies": [
                "Spring Framework"
              ]
            },
            {
              "name": "EnrollmentService",
              "path": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-service-jpa\\src\\main\\java\\org\\sidequest\\parley\\service\\EnrollmentService.java",
              "type": "class",
              "imports": [
                "org.sidequest.parley.entity.EnrollmentEntity",
                "org.sidequest.parley.mapper.EnrollmentMapper",
                "org.sidequest.parley.model.ChatRoom",
                "org.sidequest.parley.model.Enrollment",
                "org.sidequest.parley.model.NewEnrollment",
                "org.sidequest.parley.model.User",
                "org.sidequest.parley.repository.EnrollmentRepository",
                "org.springframework.beans.factory.annotation.Autowired",
                "org.springframework.stereotype.Service",
                "org.springframework.transaction.annotation.Transactional",
                "java.time.OffsetDateTime",
                "java.util.ArrayList",
                "java.util.List",
                "java.util.Set",
                "java.util.logging.Logger",
                "java.util.stream.Collectors"
              ],
              "annotations": [
                "@Service",
                "@Autowired",
                "@Autowired",
                "@Transactional",
                "@Transactional",
                "@Transactional",
                "@Transactional"
              ],
              "content": "package org.sidequest.parley.service;\r\n\r\nimport org.sidequest.parley.entity.EnrollmentEntity;\r\nimport org.sidequest.parley.mapper.EnrollmentMapper;\r\nimport org.sidequest.parley.model.ChatRoom;\r\nimport org.sidequest.parley.model.Enrollment;\r\nimport org.sidequest.parley.model.NewEnrollment;\r\nimport org.sidequest.parley.model.User;\r\nimport org.sidequest.parley.repository.EnrollmentRepository;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.stereotype.Service;\r\nimport org.springframework.transaction.annotation.Transactional;\r\n\r\nimport java.time.OffsetDateTime;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.Set;\r\nimport java.util.logging.Logger;\r\nimport java.util.stream.Collectors;\r\n\r\n@Service\r\npublic class EnrollmentService {\r\n    private static final Logger log = Logger.getLogger(EnrollmentService.class.getName());\r\n\r\n    @Autowired\r\n    private ChatRoomService chatRoomService;\r\n\r\n    private EnrollmentRepository enrollmentRepository;\r\n\r\n    @Autowired\r\n    public void setEnrollmentRepository(EnrollmentRepository enrollmentRepository) {\r\n        this.enrollmentRepository = enrollmentRepository;\r\n    }\r\n\r\n\r\n    public List<Enrollment> addUsersToChatRoom(List<User> users, ChatRoom chatRoom) {\r\n        List<Enrollment> enrollments = new ArrayList<>();\r\n        log.info(\"Adding \" + users.size() + \" users to chat room: \" + chatRoom.getName());\r\n        for (User user : users) {\r\n            Enrollment enrollment = addUserToChatRoom(user, chatRoom);\r\n            enrollments.add(enrollment);\r\n        }\r\n        return enrollments;\r\n    }\r\n\r\n    public List<Enrollment> addUsersToChatRoom(List<NewEnrollment> enrollments) {\r\n        List<Enrollment> resultEnrollments = new ArrayList<>();\r\n        log.info(\"Adding \" + enrollments.size() + \" users to chat rooms\");\r\n        OffsetDateTime now = OffsetDateTime.now();\r\n        for (NewEnrollment enrollment : enrollments) {\r\n            Long chatRoomId = enrollment.getChatRoomId();\r\n            Long userId = enrollment.getUserId();\r\n            Enrollment e = addUserToChatRoom(chatRoomId, userId);\r\n            resultEnrollments.add(e);\r\n        }\r\n        return resultEnrollments;\r\n    }\r\n\r\n\r\n    @Transactional\r\n    public Enrollment addUserToChatRoom(User user, ChatRoom chatRoom) {\r\n        Long userId = user.getId();\r\n        Long chatRoomId = chatRoom.getChatRoomId();\r\n\r\n        log.info(\"Adding user: \"\r\n                + user.getName()\r\n                + \" (\" + user.getId() + \") to chat room: \"\r\n                + chatRoom.getName()\r\n                + \" (\" + chatRoom.getChatRoomId() + \")\");\r\n\r\n        Enrollment enrollment = addUserToChatRoom(chatRoomId, userId);\r\n        return enrollment;\r\n    }\r\n\r\n    @Transactional\r\n    public Enrollment addUserToChatRoom(Long chatRoomId, Long userId) {\r\n        if (userId == null) {\r\n            log.severe(\"User ID cannot be null\");\r\n            throw new IllegalArgumentException(\"User ID cannot be null\");\r\n        }\r\n\r\n        if (chatRoomId == null) {\r\n            log.severe(\"Chat room ID cannot be null\");\r\n            throw new IllegalArgumentException(\"Chat room ID cannot be null\");\r\n        }\r\n\r\n        Enrollment enrollment = new Enrollment();\r\n        enrollment.setUserId(userId);\r\n        enrollment.setChatRoomId(chatRoomId);\r\n        EnrollmentEntity enrollmentEntity = EnrollmentMapper.INSTANCE.toEntity(enrollment);\r\n        log.info(\"Adding user with ID \" + userId + \" to chat room with ID \" + chatRoomId);\r\n        enrollmentEntity = enrollmentRepository.saveAndFlush(enrollmentEntity); // Save and flush to get the ID\r\n        return EnrollmentMapper.INSTANCE.toModel(enrollmentEntity);\r\n    }\r\n\r\n    public Enrollment getChatRoomEnrollment(Long chatRoomId, Long userId) {\r\n        EnrollmentEntity enrollmentEntity = enrollmentRepository.findByChatroomIdAndChatuserId(chatRoomId, userId)\r\n                .orElseThrow(() -> new RuntimeException(\"Enrollment not found\"));\r\n        return EnrollmentMapper.INSTANCE.toModel(enrollmentEntity);\r\n    }\r\n\r\n\r\n    public List<Enrollment> getEnrollmentsByChatRoomId(Long chatRoomId) {\r\n        Set<EnrollmentEntity> enrollmentEntities = enrollmentRepository.findByChatroomId(chatRoomId);\r\n        return enrollmentEntities.stream()\r\n                .map(EnrollmentMapper.INSTANCE::toModel)\r\n                .collect(Collectors.toList());\r\n    }\r\n\r\n    @Transactional\r\n    public void removeUserFromChatRoom(Long chatRoomId, Long userId) {\r\n        log.info(\"Removing user with ID \" + userId + \" from chat room with ID \" + chatRoomId);\r\n        enrollmentRepository.deleteByChatroomIdAndChatuserId(chatRoomId, userId);\r\n    }\r\n\r\n\r\n    @Transactional\r\n    public void removeUsersFromChatRoom(Long chatRoomId) {\r\n        log.info(\"Removing users from chat room with ID \" + chatRoomId);\r\n        enrollmentRepository.deleteByChatroomId(chatRoomId);\r\n    }\r\n\r\n    public Set<Long> getChatRoomByUserIds(Long chatRoomId) {\r\n        Set<EnrollmentEntity> enrollmentEntities = enrollmentRepository.findByChatroomId(chatRoomId);\r\n        return enrollmentEntities.stream()\r\n                .map(EnrollmentMapper.INSTANCE::toModel)\r\n                .map(Enrollment::getUserId) // Correctly map to user IDs\r\n                .collect(Collectors.toSet());\r\n\r\n    }\r\n\r\n    //20241206 - This method worked\r\n//    public List<ChatRoom> getChatRoomsByUserId(Long userId) {\r\n//        Set<EnrollmentEntity> enrollments = enrollmentRepository.findAllByChatuserId(userId);\r\n//        return enrollments.stream()\r\n//                .map(EnrollmentMapper.INSTANCE::toModel)\r\n//                .map(enrollment -> {\r\n//                    ChatRoom chatRoom = new ChatRoom();\r\n//                    chatRoom.setChatRoomId(enrollment.getChatRoomId());\r\n//                    return chatRoom;\r\n//                })\r\n//                .collect(Collectors.toList());\r\n//    }\r\n\r\n    public List<ChatRoom> getChatRoomsByUserId(Long userId) {\r\n        Set<EnrollmentEntity> enrollments = enrollmentRepository.findAllByChatuserId(userId);\r\n        return enrollments.stream()\r\n                .map(EnrollmentMapper.INSTANCE::toModel)\r\n                .map(enrollment -> chatRoomService.getChatRoom(enrollment.getChatRoomId()))\r\n                .filter(chatRoom -> chatRoom != null)\r\n                .collect(Collectors.toList());\r\n    }\r\n\r\n    public boolean isUserInChatRoom(Long userId, Long chatRoomId) {\r\n        return enrollmentRepository.existsByChatroomIdAndChatuserId(chatRoomId, userId);\r\n    }\r\n}\r\n",
              "methods": [
                {
                  "name": "setEnrollmentRepository",
                  "returnType": "Autowired\r\n    public void",
                  "parameters": [
                    "EnrollmentRepository enrollmentRepository"
                  ],
                  "annotations": [
                    "@Autowired"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "addUsersToChatRoom",
                  "returnType": "public List<Enrollment>",
                  "parameters": [
                    "List<User> users",
                    "ChatRoom chatRoom"
                  ],
                  "annotations": [
                    "@Autowired"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "for",
                  "returnType": "",
                  "parameters": [
                    "User user : users"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "addUsersToChatRoom",
                  "returnType": "public List<Enrollment>",
                  "parameters": [
                    "List<NewEnrollment> enrollments"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "for",
                  "returnType": "",
                  "parameters": [
                    "NewEnrollment enrollment : enrollments"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "addUserToChatRoom",
                  "returnType": "Transactional\r\n    public Enrollment",
                  "parameters": [
                    "User user",
                    "ChatRoom chatRoom"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "addUserToChatRoom",
                  "returnType": "Transactional\r\n    public Enrollment",
                  "parameters": [
                    "Long chatRoomId",
                    "Long userId"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "if",
                  "returnType": "",
                  "parameters": [
                    "userId == null"
                  ],
                  "annotations": [
                    "@Transactional"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "IllegalArgumentException",
                  "returnType": "throw new",
                  "parameters": [
                    "\"User ID cannot be null\""
                  ],
                  "annotations": [
                    "@Transactional"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "if",
                  "returnType": "",
                  "parameters": [
                    "chatRoomId == null"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "IllegalArgumentException",
                  "returnType": "throw new",
                  "parameters": [
                    "\"Chat room ID cannot be null\""
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "Enrollment",
                  "returnType": "new",
                  "parameters": [],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "getChatRoomEnrollment",
                  "returnType": "public Enrollment",
                  "parameters": [
                    "Long chatRoomId",
                    "Long userId"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "getEnrollmentsByChatRoomId",
                  "returnType": "public List<Enrollment>",
                  "parameters": [
                    "Long chatRoomId"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "removeUserFromChatRoom",
                  "returnType": "Transactional\r\n    public void",
                  "parameters": [
                    "Long chatRoomId",
                    "Long userId"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "removeUsersFromChatRoom",
                  "returnType": "Transactional\r\n    public void",
                  "parameters": [
                    "Long chatRoomId"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "getChatRoomByUserIds",
                  "returnType": "public Set<Long>",
                  "parameters": [
                    "Long chatRoomId"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "getChatRoomsByUserId",
                  "returnType": "public List<ChatRoom>",
                  "parameters": [
                    "Long userId"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "ChatRoom",
                  "returnType": "new",
                  "parameters": [],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "getChatRoomsByUserId",
                  "returnType": "public List<ChatRoom>",
                  "parameters": [
                    "Long userId"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "isUserInChatRoom",
                  "returnType": "public boolean",
                  "parameters": [
                    "Long userId",
                    "Long chatRoomId"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                }
              ],
              "businessRules": [],
              "relatedClasses": [],
              "dependencies": [
                "Spring Framework"
              ]
            },
            {
              "name": "FileService",
              "path": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-service-jpa\\src\\main\\java\\org\\sidequest\\parley\\service\\FileService.java",
              "type": "class",
              "imports": [
                "org.springframework.beans.factory.annotation.Value",
                "org.springframework.stereotype.Service",
                "org.springframework.web.multipart.MultipartFile",
                "java.nio.file.Files",
                "java.nio.file.Path",
                "java.nio.file.Paths"
              ],
              "annotations": [
                "@Service",
                "@Value(\"${app.fileDirectory}\")"
              ],
              "content": "package org.sidequest.parley.service;\r\n\r\nimport org.springframework.beans.factory.annotation.Value;\r\nimport org.springframework.stereotype.Service;\r\nimport org.springframework.web.multipart.MultipartFile;\r\n\r\nimport java.nio.file.Files;\r\nimport java.nio.file.Path;\r\nimport java.nio.file.Paths;\r\n\r\n@Service\r\npublic class FileService {\r\n\r\n    @Value(\"${app.fileDirectory}\")\r\n    private String uploadDir;\r\n\r\n    public void saveImage(MultipartFile file) throws Exception {\r\n        if (!file.isEmpty()) {\r\n            byte[] bytes = file.getBytes();\r\n            Path path = Paths.get(uploadDir + file.getOriginalFilename());\r\n            Files.write(path, bytes);\r\n        } else {\r\n            throw new Exception(\"Empty file!\");\r\n        }\r\n    }\r\n}",
              "methods": [
                {
                  "name": "saveImage",
                  "returnType": "public void",
                  "parameters": [
                    "MultipartFile file"
                  ],
                  "annotations": [
                    "@Service",
                    "@Value(\"${app.fileDirectory}\")"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": [
                    "Exception"
                  ]
                },
                {
                  "name": "Exception",
                  "returnType": "throw new",
                  "parameters": [
                    "\"Empty file!\""
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                }
              ],
              "businessRules": [],
              "relatedClasses": [],
              "dependencies": [
                "Spring Framework"
              ]
            },
            {
              "name": "JwtUserDetailsService",
              "path": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-service-jpa\\src\\main\\java\\org\\sidequest\\parley\\service\\JwtUserDetailsService.java",
              "type": "class",
              "imports": [
                "lombok.RequiredArgsConstructor",
                "org.sidequest.parley.repository.UserRepository",
                "org.springframework.security.core.userdetails.UserDetails",
                "org.springframework.security.core.userdetails.UserDetailsService",
                "org.springframework.security.core.userdetails.UsernameNotFoundException",
                "org.springframework.stereotype.Service"
              ],
              "annotations": [
                "@Service",
                "@RequiredArgsConstructor",
                "@Override"
              ],
              "content": "package org.sidequest.parley.service;\r\n\r\nimport lombok.RequiredArgsConstructor;\r\nimport org.sidequest.parley.repository.UserRepository;\r\nimport org.springframework.security.core.userdetails.UserDetails;\r\nimport org.springframework.security.core.userdetails.UserDetailsService;\r\nimport org.springframework.security.core.userdetails.UsernameNotFoundException;\r\nimport org.springframework.stereotype.Service;\r\n\r\n@Service\r\n@RequiredArgsConstructor\r\npublic class JwtUserDetailsService implements UserDetailsService {\r\n\r\n    private final UserRepository userRepository;\r\n\r\n    @Override\r\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\r\n        return userRepository.findByName(username)\r\n                .orElseThrow(() -> new UsernameNotFoundException(\"User not found with username: \" + username));\r\n    }\r\n}",
              "methods": [
                {
                  "name": "loadUserByUsername",
                  "returnType": "Override\r\n    public UserDetails",
                  "parameters": [
                    "String username"
                  ],
                  "annotations": [
                    "@Service",
                    "@RequiredArgsConstructor"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": [
                    "UsernameNotFoundException"
                  ]
                }
              ],
              "businessRules": [],
              "relatedClasses": [
                "UserDetailsService"
              ],
              "dependencies": [
                "Spring Framework"
              ]
            },
            {
              "name": "UserService",
              "path": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-service-jpa\\src\\main\\java\\org\\sidequest\\parley\\service\\UserService.java",
              "type": "class",
              "imports": [
                "jakarta.validation.constraints.NotNull",
                "jakarta.validation.constraints.Size",
                "org.sidequest.parley.entity.ChatRoomEntity",
                "org.sidequest.parley.entity.UserEntity",
                "org.sidequest.parley.mapper.ChatRoomMapper",
                "org.sidequest.parley.mapper.UserMapper",
                "org.sidequest.parley.model.ChatRoom",
                "org.sidequest.parley.model.NewUser",
                "org.sidequest.parley.model.User",
                "org.sidequest.parley.repository.UserRepository",
                "org.sidequest.parley.util.EmailHelper",
                "org.sidequest.parley.util.FileSystemHelper",
                "org.sidequest.parley.util.TimeHelper",
                "org.springframework.beans.factory.annotation.Autowired",
                "org.springframework.beans.factory.annotation.Value",
                "org.springframework.context.annotation.Lazy",
                "org.springframework.security.crypto.password.PasswordEncoder",
                "org.springframework.stereotype.Service",
                "org.springframework.transaction.annotation.Transactional",
                "org.springframework.web.multipart.MultipartFile",
                "java.time.OffsetDateTime",
                "java.time.ZoneId",
                "java.time.zone.ZoneRulesException",
                "java.util.List",
                "java.util.UUID",
                "java.util.logging.Logger",
                "java.util.stream.Collectors"
              ],
              "annotations": [
                "@Service",
                "@Autowired",
                "@Lazy",
                "@Autowired",
                "@Autowired",
                "@Value(\"${user.avatar.directory}\")",
                "@Autowired",
                "@Autowired",
                "@Transactional",
                "@Transactional",
                "@Transactional",
                "@Transactional",
                "@Transactional",
                "@Transactional",
                "@Transactional",
                "@NotNull",
                "@Size(min = 8)",
                "@Transactional"
              ],
              "content": "package org.sidequest.parley.service;\r\n\r\nimport jakarta.validation.constraints.NotNull;\r\nimport jakarta.validation.constraints.Size;\r\nimport org.sidequest.parley.entity.ChatRoomEntity;\r\nimport org.sidequest.parley.entity.UserEntity;\r\nimport org.sidequest.parley.mapper.ChatRoomMapper;\r\nimport org.sidequest.parley.mapper.UserMapper;\r\nimport org.sidequest.parley.model.ChatRoom;\r\nimport org.sidequest.parley.model.NewUser;\r\nimport org.sidequest.parley.model.User;\r\nimport org.sidequest.parley.repository.UserRepository;\r\nimport org.sidequest.parley.util.EmailHelper;\r\nimport org.sidequest.parley.util.FileSystemHelper;\r\nimport org.sidequest.parley.util.TimeHelper;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.beans.factory.annotation.Value;\r\nimport org.springframework.context.annotation.Lazy;\r\nimport org.springframework.security.crypto.password.PasswordEncoder;\r\nimport org.springframework.stereotype.Service;\r\nimport org.springframework.transaction.annotation.Transactional;\r\nimport org.springframework.web.multipart.MultipartFile;\r\n\r\nimport java.time.OffsetDateTime;\r\nimport java.time.ZoneId;\r\nimport java.time.zone.ZoneRulesException;\r\nimport java.util.List;\r\nimport java.util.UUID;\r\nimport java.util.logging.Logger;\r\nimport java.util.stream.Collectors;\r\n\r\n@Service\r\npublic class UserService {\r\n    private static final Logger log = Logger.getLogger(UserService.class.getName());\r\n\r\n    private UserRepository userRepository;\r\n\r\n    @Autowired\r\n    @Lazy\r\n    private EnrollmentService enrollmentService;\r\n\r\n    @Autowired\r\n    private EmailHelper emailHelper; // We'll need this\r\n\r\n    @Autowired\r\n    private PasswordEncoder passwordEncoder;\r\n\r\n    @Value(\"${user.avatar.directory}\")\r\n    private String userAvatarDirectory;\r\n\r\n    @Autowired\r\n    public void setUserRepository(UserRepository userRepository) {\r\n        this.userRepository = userRepository;\r\n    }\r\n\r\n    @Autowired\r\n    private FileSystemHelper fileSystemHelper;\r\n\r\n    public List<User> getUsers() {\r\n        return userRepository.findAll().stream().map(UserMapper.INSTANCE::toModel).collect(Collectors.toList());\r\n    }\r\n\r\n    public User getUser(Long userId) {\r\n        return userRepository.findById(userId).map(UserMapper.INSTANCE::toModel).orElse(null);\r\n    }\r\n\r\n    @Transactional\r\n    public User createUser(String name, String timeZone) {\r\n        log.info(\"Creating user: \" + name + \" with timezone: \" + timeZone);\r\n        if (name == null || name.trim().isEmpty()) {\r\n            throw new IllegalArgumentException(\"User name cannot be null or empty\");\r\n        }\r\n\r\n        String timezone = getZoneId(timeZone);\r\n\r\n        User user = new User();\r\n        user.setName(name);\r\n        user.setTimezone(timezone);\r\n        UserEntity userEntity = UserMapper.INSTANCE.toEntity(user);\r\n        userEntity = userRepository.save(userEntity);\r\n        log.info(\"User created: \" + userEntity.toString());\r\n        return UserMapper.INSTANCE.toModel(userEntity);\r\n    }\r\n\r\n    private String getZoneId(String timezone) {\r\n        TimeHelper timeHelper;\r\n        try {\r\n            timeHelper = new TimeHelper();\r\n            String result = timeHelper.getZoneId(timezone).toString();\r\n            return result != null ? result : timeHelper.getDefaultZoneId().toString();\r\n        } catch (ZoneRulesException e) {\r\n            timeHelper = new TimeHelper();\r\n            return timeHelper.getDefaultZoneId().toString();\r\n        }\r\n    }\r\n\r\n    private boolean isTimezone(String timezone) {\r\n        try {\r\n            ZoneId.of(timezone);\r\n            return true;\r\n        } catch (ZoneRulesException e) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    @Transactional\r\n    public User updateUserById(Long id, NewUser user) {\r\n        UserEntity userEntity = userRepository.findById(id).orElseThrow(() -> new RuntimeException(\"User not found\"));\r\n\r\n        if (user.getName() != null && !user.getName().isEmpty()) {\r\n            userEntity.setName(user.getName());\r\n        }\r\n        if (user.getTimezone() != null && !user.getTimezone().isEmpty()) {\r\n            String timezone = getZoneId(user.getTimezone());\r\n            userEntity.setTimezone(timezone);\r\n        }\r\n\r\n\r\n        userEntity = userRepository.save(userEntity);\r\n        return UserMapper.INSTANCE.toModel(userEntity);\r\n    }\r\n\r\n\r\n    public List<ChatRoom> getChatRoomsByUserId(Long userId) {\r\n        try {\r\n            if (userId == null) {\r\n                log.warning(\"User ID cannot be null\");\r\n                throw new IllegalArgumentException(\"User ID cannot be null\");\r\n            }\r\n\r\n            if (!userRepository.existsById(userId)) {\r\n                log.warning(\"User not found with id: \" + userId);\r\n                throw new IllegalArgumentException(\"User not found with id: \" + userId);\r\n            }\r\n\r\n            List<ChatRoom> chatRooms = enrollmentService.getChatRoomsByUserId(userId);\r\n            log.info(\"Found \" + chatRooms.size() + \" chat rooms for user \" + userId);\r\n            return chatRooms;\r\n        } catch (IllegalArgumentException e) {\r\n            log.severe(\"Invalid request for user chatrooms: \" + e.getMessage());\r\n            throw e;\r\n        } catch (Exception e) {\r\n            log.severe(\"Error getting chat rooms for user \" + userId + \": \" + e.getMessage());\r\n            throw new RuntimeException(\"Error retrieving chat rooms\", e);\r\n        }\r\n    }\r\n\r\n    private ChatRoom mapChatRoomEntityToChatRoom(ChatRoomEntity entity) {\r\n        return ChatRoomMapper.INSTANCE.toModel(entity);\r\n    }\r\n\r\n    @Transactional\r\n    public void updateLastPostedMessageDateTime(Long userId, OffsetDateTime odt) {\r\n        log.info(\"Updating last posted message date time for user: \" + userId);\r\n        UserEntity userEntity = userRepository.findById(userId)\r\n                .orElseThrow(() -> new RuntimeException(\"User not found\"));\r\n        userEntity.setLastPostedMessageDateTime(odt);\r\n        userRepository.save(userEntity);\r\n    }\r\n\r\n    @Transactional\r\n    public void setUserAvatar(Long userId, MultipartFile avatarFile) throws Exception {\r\n        if (!avatarFile.isEmpty()) {\r\n            log.fine(\"Saving avatar for user: \" + userId);\r\n        UserEntity user = userRepository.findById(userId).orElseThrow(() -> new Exception(\"User not found\"));\r\n            String path = fileSystemHelper.saveFile(avatarFile, userAvatarDirectory);\r\n            user.setAvatarPath(path);\r\n            userRepository.save(user);\r\n        } else {\r\n            log.severe(\"Empty file!\");\r\n            throw new Exception(\"Empty file!\");\r\n        }\r\n    }\r\n\r\n    public String getUserAvatar(Long userId) throws Exception {\r\n        UserEntity user = userRepository.findById(userId).orElseThrow(() -> new Exception(\"User not found\"));\r\n        return user.getAvatarPath();\r\n    }\r\n\r\n    public String getUserTimezone(Long userId) {\r\n        UserEntity userEntity = userRepository.findById(userId)\r\n                .orElseThrow(() -> new RuntimeException(\"User not found\"));\r\n        String strUserTimezone = userEntity.getTimezone();\r\n        return getZoneId(strUserTimezone);\r\n    }\r\n\r\n    public UserEntity getUserEntity(Long id) {\r\n        return userRepository.findById(id).orElseThrow(() -> new RuntimeException(\"User not found\"));\r\n    }\r\n\r\n    @Transactional\r\n    public void requestPasswordReset(String email) {\r\n        UserEntity user = userRepository.findByEmail(email)\r\n                .orElseThrow(() -> new IllegalArgumentException(\"User not found with email: \" + email));\r\n\r\n        // Generate a unique password reset token\r\n        String resetToken = UUID.randomUUID().toString();\r\n\r\n        // Set the token and expiration time in the user entity\r\n        user.setPasswordResetToken(resetToken);\r\n        user.setPasswordResetTokenExpiration(OffsetDateTime.now().plusHours(24)); // Token valid for 24 hours\r\n\r\n        // Save the updated user entity\r\n        userRepository.save(user);\r\n\r\n        // Send the password reset email\r\n        emailHelper.sendPasswordResetEmail(user.getEmail(), resetToken);\r\n    }\r\n\r\n    @Transactional\r\n    public boolean validatePasswordResetToken(String token) {\r\n        UserEntity user = userRepository.findByPasswordResetToken(token)\r\n                .orElseThrow(() -> new IllegalArgumentException(\"Invalid reset token\"));\r\n\r\n        if (user.getPasswordResetTokenExpiration().isBefore(OffsetDateTime.now())) {\r\n            throw new IllegalArgumentException(\"Reset token has expired\");\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    @Transactional\r\n    public void resetPassword(String token, String newPassword, @NotNull @Size(min = 8) String confirmPassword) {\r\n        if (!newPassword.equals(confirmPassword)) {\r\n            throw new IllegalArgumentException(\"Passwords do not match\");\r\n        }\r\n\r\n        UserEntity user = userRepository.findByPasswordResetToken(token)\r\n                .orElseThrow(() -> new IllegalArgumentException(\"Invalid reset token\"));\r\n\r\n        if (user.getPasswordResetTokenExpiration().isBefore(OffsetDateTime.now())) {\r\n            throw new IllegalArgumentException(\"Reset token has expired\");\r\n        }\r\n\r\n        // Encode password before saving\r\n        user.setMagic(passwordEncoder.encode(newPassword));\r\n        user.setPasswordResetToken(null);\r\n        user.setPasswordResetTokenExpiration(null);\r\n        userRepository.save(user);\r\n\r\n        log.info(\"Password successfully reset for user: \" + user.getId());\r\n    }\r\n\r\n    @Transactional\r\n    public void changePassword(Long userId, String currentPassword, String newPassword) {\r\n        UserEntity user = userRepository.findById(userId)\r\n                .orElseThrow(() -> new RuntimeException(\"User not found\"));\r\n\r\n        // Verify current password\r\n        if (!passwordEncoder.matches(currentPassword, user.getMagic())) {\r\n            throw new IllegalArgumentException(\"Current password is incorrect\");\r\n        }\r\n\r\n        // Validate new password\r\n        if (newPassword == null || newPassword.length() < 8) {\r\n            throw new IllegalArgumentException(\"New password must be at least 8 characters long\");\r\n        }\r\n\r\n        // Encode and set new password\r\n        user.setMagic(passwordEncoder.encode(newPassword));\r\n        userRepository.save(user);\r\n\r\n        log.info(\"Password successfully changed for user: \" + userId);\r\n    }\r\n}",
              "methods": [
                {
                  "name": "setUserRepository",
                  "returnType": "Autowired\r\n    public void",
                  "parameters": [
                    "UserRepository userRepository"
                  ],
                  "annotations": [
                    "@Autowired",
                    "@Value(\"${user.avatar.directory}\")"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "getUsers",
                  "returnType": "public List<User>",
                  "parameters": [],
                  "annotations": [
                    "@Autowired",
                    "@Autowired"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "getUser",
                  "returnType": "public User",
                  "parameters": [
                    "Long userId"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "createUser",
                  "returnType": "Transactional\r\n    public User",
                  "parameters": [
                    "String name",
                    "String timeZone"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "IllegalArgumentException",
                  "returnType": "throw new",
                  "parameters": [
                    "\"User name cannot be null or empty\""
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "User",
                  "returnType": "new",
                  "parameters": [],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "getZoneId",
                  "returnType": "private String",
                  "parameters": [
                    "String timezone"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "TimeHelper",
                  "returnType": "new",
                  "parameters": [],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "TimeHelper",
                  "returnType": "new",
                  "parameters": [],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "isTimezone",
                  "returnType": "private boolean",
                  "parameters": [
                    "String timezone"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "updateUserById",
                  "returnType": "Transactional\r\n    public User",
                  "parameters": [
                    "Long id",
                    "NewUser user"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "getChatRoomsByUserId",
                  "returnType": "public List<ChatRoom>",
                  "parameters": [
                    "Long userId"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "if",
                  "returnType": "",
                  "parameters": [
                    "userId == null"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "IllegalArgumentException",
                  "returnType": "throw new",
                  "parameters": [
                    "\"User ID cannot be null\""
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "IllegalArgumentException",
                  "returnType": "throw new",
                  "parameters": [
                    "\"User not found with id: \" + userId"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "RuntimeException",
                  "returnType": "throw new",
                  "parameters": [
                    "\"Error retrieving chat rooms\"",
                    "e"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "mapChatRoomEntityToChatRoom",
                  "returnType": "private ChatRoom",
                  "parameters": [
                    "ChatRoomEntity entity"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "updateLastPostedMessageDateTime",
                  "returnType": "Transactional\r\n    public void",
                  "parameters": [
                    "Long userId",
                    "OffsetDateTime odt"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "setUserAvatar",
                  "returnType": "Transactional\r\n    public void",
                  "parameters": [
                    "Long userId",
                    "MultipartFile avatarFile"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": [
                    "Exception"
                  ]
                },
                {
                  "name": "Exception",
                  "returnType": "throw new",
                  "parameters": [
                    "\"Empty file!\""
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "getUserAvatar",
                  "returnType": "public String",
                  "parameters": [
                    "Long userId"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": [
                    "Exception"
                  ]
                },
                {
                  "name": "getUserTimezone",
                  "returnType": "public String",
                  "parameters": [
                    "Long userId"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "getZoneId",
                  "returnType": "return",
                  "parameters": [
                    "strUserTimezone"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "getUserEntity",
                  "returnType": "public UserEntity",
                  "parameters": [
                    "Long id"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "requestPasswordReset",
                  "returnType": "Transactional\r\n    public void",
                  "parameters": [
                    "String email"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "validatePasswordResetToken",
                  "returnType": "Transactional\r\n    public boolean",
                  "parameters": [
                    "String token"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "IllegalArgumentException",
                  "returnType": "throw new",
                  "parameters": [
                    "\"Reset token has expired\""
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "IllegalArgumentException",
                  "returnType": "throw new",
                  "parameters": [
                    "\"Passwords do not match\""
                  ],
                  "annotations": [
                    "@Transactional"
                  ],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "IllegalArgumentException",
                  "returnType": "throw new",
                  "parameters": [
                    "\"Reset token has expired\""
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "changePassword",
                  "returnType": "Transactional\r\n    public void",
                  "parameters": [
                    "Long userId",
                    "String currentPassword",
                    "String newPassword"
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "IllegalArgumentException",
                  "returnType": "throw new",
                  "parameters": [
                    "\"Current password is incorrect\""
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                },
                {
                  "name": "IllegalArgumentException",
                  "returnType": "throw new",
                  "parameters": [
                    "\"New password must be at least 8 characters long\""
                  ],
                  "annotations": [],
                  "visibility": "package-private",
                  "isAsync": false,
                  "exceptions": []
                }
              ],
              "businessRules": [
                "We'll need this\r\n\r\n    @Autowired\r\n    private PasswordEncoder passwordEncoder;\r\n\r\n    @Value(\"${user.avatar.directory}\")\r\n    private String userAvatarDirectory;\r\n\r\n    @Autowired\r\n    public void setUserRepository(UserRepository userRepository) {\r\n        this.userRepository = userRepository;\r\n    }\r\n\r\n    @Autowired\r\n    private FileSystemHelper fileSystemHelper;\r\n\r\n    public List<User> getUsers() {\r\n        return userRepository.findAll().stream().map(UserMapper.INSTANCE::toModel).collect(Collectors.toList());\r\n    }\r\n\r\n    public User getUser(Long userId) {\r\n        return userRepository.findById(userId).map(UserMapper.INSTANCE::toModel).orElse(null);\r\n    }\r\n\r\n    @Transactional\r\n    public User createUser(String name, String timeZone) {\r\n        log.info(\"Creating user: \" + name + \" with timezone: \" + timeZone);\r\n        if (name == null || name.trim().isEmpty()) {\r\n            throw new IllegalArgumentException(\"User name cannot be null or empty\");\r\n        }\r\n\r\n        String timezone = getZoneId(timeZone);\r\n\r\n        User user = new User();\r\n        user.setName(name);\r\n        user.setTimezone(timezone);\r\n        UserEntity userEntity = UserMapper.INSTANCE.toEntity(user);\r\n        userEntity = userRepository.save(userEntity);\r\n        log.info(\"User created: \" + userEntity.toString());\r\n        return UserMapper.INSTANCE.toModel(userEntity);\r\n    }\r\n\r\n    private String getZoneId(String timezone) {\r\n        TimeHelper timeHelper;\r\n        try {\r\n            timeHelper = new TimeHelper();\r\n            String result = timeHelper.getZoneId(timezone).toString();\r\n            return result != null ? result : timeHelper.getDefaultZoneId().toString();\r\n        } catch (ZoneRulesException e) {\r\n            timeHelper = new TimeHelper();\r\n            return timeHelper.getDefaultZoneId().toString();\r\n        }\r\n    }\r\n\r\n    private boolean isTimezone(String timezone) {\r\n        try {\r\n            ZoneId.of(timezone);\r\n            return true;\r\n        } catch (ZoneRulesException e) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    @Transactional\r\n    public User updateUserById(Long id, NewUser user) {\r\n        UserEntity userEntity = userRepository.findById(id).orElseThrow(() -> new RuntimeException(\"User not found\"));\r\n\r\n        if (user.getName() != null && !user.getName().isEmpty()) {\r\n            userEntity.setName(user.getName());\r\n        }\r\n        if (user.getTimezone() != null && !user.getTimezone().isEmpty()) {\r\n            String timezone = getZoneId(user.getTimezone());\r\n            userEntity.setTimezone(timezone);\r\n        }\r\n\r\n\r\n        userEntity = userRepository.save(userEntity);\r\n        return UserMapper.INSTANCE.toModel(userEntity);\r\n    }\r\n\r\n\r\n    public List<ChatRoom> getChatRoomsByUserId(Long userId) {\r\n        try {\r\n            if (userId == null) {\r\n                log.warning(\"User ID cannot be null\");\r\n                throw new IllegalArgumentException(\"User ID cannot be null\");\r\n            }\r\n\r\n            if (!userRepository.existsById(userId)) {\r\n                log.warning(\"User not found with id: \" + userId);\r\n                throw new IllegalArgumentException(\"User not found with id: \" + userId);\r\n            }\r\n\r\n            List<ChatRoom> chatRooms = enrollmentService.getChatRoomsByUserId(userId);\r\n            log.info(\"Found \" + chatRooms.size() + \" chat rooms for user \" + userId);\r\n            return chatRooms;\r\n        } catch (IllegalArgumentException e) {\r\n            log.severe(\"Invalid request for user chatrooms: \" + e.getMessage());\r\n            throw e;\r\n        } catch (Exception e) {\r\n            log.severe(\"Error getting chat rooms for user \" + userId + \": \" + e.getMessage());\r\n            throw new RuntimeException(\"Error retrieving chat rooms\", e);\r\n        }\r\n    }\r\n\r\n    private ChatRoom mapChatRoomEntityToChatRoom(ChatRoomEntity entity) {\r\n        return ChatRoomMapper.INSTANCE.toModel(entity);\r\n    }\r\n\r\n    @Transactional\r\n    public void updateLastPostedMessageDateTime(Long userId, OffsetDateTime odt) {\r\n        log.info(\"Updating last posted message date time for user: \" + userId);\r\n        UserEntity userEntity = userRepository.findById(userId)\r\n                .orElseThrow(() -> new RuntimeException(\"User not found\"));\r\n        userEntity.setLastPostedMessageDateTime(odt);\r\n        userRepository.save(userEntity);\r\n    }\r\n\r\n    @Transactional\r\n    public void setUserAvatar(Long userId, MultipartFile avatarFile) throws Exception {\r\n        if (!avatarFile.isEmpty()) {\r\n            log.fine(\"Saving avatar for user: \" + userId);\r\n        UserEntity user = userRepository.findById(userId).orElseThrow(() -> new Exception(\"User not found\"));\r\n            String path = fileSystemHelper.saveFile(avatarFile, userAvatarDirectory);\r\n            user.setAvatarPath(path);\r\n            userRepository.save(user);\r\n        } else {\r\n            log.severe(\"Empty file!\");\r\n            throw new Exception(\"Empty file!\");\r\n        }\r\n    }\r\n\r\n    public String getUserAvatar(Long userId) throws Exception {\r\n        UserEntity user = userRepository.findById(userId).orElseThrow(() -> new Exception(\"User not found\"));\r\n        return user.getAvatarPath();\r\n    }\r\n\r\n    public String getUserTimezone(Long userId) {\r\n        UserEntity userEntity = userRepository.findById(userId)\r\n                .orElseThrow(() -> new RuntimeException(\"User not found\"));\r\n        String strUserTimezone = userEntity.getTimezone();\r\n        return getZoneId(strUserTimezone);\r\n    }\r\n\r\n    public UserEntity getUserEntity(Long id) {\r\n        return userRepository.findById(id).orElseThrow(() -> new RuntimeException(\"User not found\"));\r\n    }\r\n\r\n    @Transactional\r\n    public void requestPasswordReset(String email) {\r\n        UserEntity user = userRepository.findByEmail(email)\r\n                .orElseThrow(() -> new IllegalArgumentException(\"User not found with email: \" + email));\r\n\r\n        // Generate a unique password reset token\r\n        String resetToken = UUID.randomUUID().toString();\r\n\r\n        // Set the token and expiration time in the user entity\r\n        user.setPasswordResetToken(resetToken);\r\n        user.setPasswordResetTokenExpiration(OffsetDateTime.now().plusHours(24)); // Token valid for 24 hours\r\n\r\n        // Save the updated user entity\r\n        userRepository.save(user);\r\n\r\n        // Send the password reset email\r\n        emailHelper.sendPasswordResetEmail(user.getEmail(), resetToken);\r\n    }\r\n\r\n    @Transactional\r\n    public boolean validatePasswordResetToken(String token) {\r\n        UserEntity user = userRepository.findByPasswordResetToken(token)\r\n                .orElseThrow(() -> new IllegalArgumentException(\"Invalid reset token\"));\r\n\r\n        if (user.getPasswordResetTokenExpiration().isBefore(OffsetDateTime.now())) {\r\n            throw new IllegalArgumentException(\"Reset token has expired\");\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    @Transactional\r\n    public void resetPassword(String token, String newPassword, @NotNull @Size(min = 8) String confirmPassword) {\r\n        if (!newPassword.equals(confirmPassword)) {\r\n            throw new IllegalArgumentException(\"Passwords do not match\");\r\n        }\r\n\r\n        UserEntity user = userRepository.findByPasswordResetToken(token)\r\n                .orElseThrow(() -> new IllegalArgumentException(\"Invalid reset token\"));\r\n\r\n        if (user.getPasswordResetTokenExpiration().isBefore(OffsetDateTime.now())) {\r\n            throw new IllegalArgumentException(\"Reset token has expired\");\r\n        }\r\n\r\n        // Encode password before saving\r\n        user.setMagic(passwordEncoder.encode(newPassword));\r\n        user.setPasswordResetToken(null);\r\n        user.setPasswordResetTokenExpiration(null);\r\n        userRepository.save(user);\r\n\r\n        log.info(\"Password successfully reset for user: \" + user.getId());\r\n    }\r\n\r\n    @Transactional\r\n    public void changePassword(Long userId, String currentPassword, String newPassword) {\r\n        UserEntity user = userRepository.findById(userId)\r\n                .orElseThrow(() -> new RuntimeException(\"User not found\"));\r\n\r\n        // Verify current password\r\n        if (!passwordEncoder.matches(currentPassword, user.getMagic())) {\r\n            throw new IllegalArgumentException(\"Current password is incorrect\");\r\n        }\r\n\r\n        // Validate new password\r\n        if (newPassword == null || newPassword.length() < 8) {\r\n            throw new IllegalArgumentException(\"New password must be at least 8 characters long\");\r\n        }\r\n\r\n        // Encode and set new password\r\n        user.setMagic(passwordEncoder.encode(newPassword));\r\n        userRepository.save(user);\r\n\r\n        log.info(\"Password successfully changed for user: \" + userId);\r\n    }\r\n}"
              ],
              "relatedClasses": [],
              "dependencies": [
                "Spring Framework"
              ]
            }
          ]
        }
      ],
      "resources": {
        "application.properties": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-service-jpa\\src\\main\\resources\\application.properties",
        "reformatted_import.txt": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-service-jpa\\src\\main\\resources\\reformatted_import.txt",
        "db_table_chatmessages": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-service-jpa\\src\\main\\java\\org\\sidequest\\parley\\entity\\ChatMessageEntity.java",
        "db_table_chatrooms": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-service-jpa\\src\\main\\java\\org\\sidequest\\parley\\entity\\ChatRoomEntity.java",
        "application-mysql.properties": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-service-jpa\\src\\main\\resources\\application-mysql.properties",
        "logback-spring.xml.old": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-service-jpa\\src\\main\\resources\\logback-spring.xml.old",
        "db_table_chatusers": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-service-jpa\\src\\main\\java\\org\\sidequest\\parley\\entity\\UserEntity.java",
        "application-postgres.properties": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-service-jpa\\src\\main\\resources\\application-postgres.properties",
        "import.sql.backup": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-service-jpa\\src\\main\\resources\\import.sql.backup",
        "logback.xml.old": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-service-jpa\\src\\main\\resources\\logback.xml.old",
        "application-sqlite.properties": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-service-jpa\\src\\main\\resources\\application-sqlite.properties",
        "db_table_chatrooms_chatusers": "C:\\Users\\jrack\\IdeaProjects\\parley\\parley-service-jpa\\src\\main\\java\\org\\sidequest\\parley\\entity\\EnrollmentEntity.java"
      },
      "dependencies": [],
      "apiEndpoints": {}
    }
  ],
  "dependencies": [
    "Maven"
  ],
  "designPatterns": {},
  "securityFeatures": {},
  "configurations": {},
  "dbSchema": {}
}